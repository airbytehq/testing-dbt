2021-12-02 20:53:13.423498 (MainThread): Running with dbt=0.21.0
2021-12-02 20:53:13.727646 (MainThread): running dbt with arguments Namespace(cls=<class 'dbt.task.run.RunTask'>, debug=False, defer=None, exclude=None, fail_fast=False, full_refresh=False, log_cache_events=False, log_format='default', partial_parse=None, profile=None, profiles_dir='/data/db_redshift', project_dir='/data/second_project', record_timing_info=None, rpc_method='run', select=None, selector_name=None, single_threaded=False, state=None, strict=False, target=None, test_new_parser=False, threads=None, use_cache=True, use_colors=None, use_experimental_parser=False, vars='{}', version_check=True, warn_error=False, which='run', write_json=True)
2021-12-02 20:53:13.736272 (MainThread): Tracking: do not track
2021-12-02 20:53:13.759339 (MainThread): Unable to do partial parsing because target/partial_parse.msgpack not found
2021-12-02 20:53:13.846069 (MainThread): Parsing ../macros/boolean_values.sql
2021-12-02 20:53:13.851513 (MainThread): Parsing ../macros/normalize_identifier.sql
2021-12-02 20:53:13.855377 (MainThread): Parsing macros/catalog.sql
2021-12-02 20:53:13.878070 (MainThread): Parsing macros/relations.sql
2021-12-02 20:53:13.881559 (MainThread): Parsing macros/adapters.sql
2021-12-02 20:53:13.931978 (MainThread): Parsing macros/materializations/snapshot_merge.sql
2021-12-02 20:53:13.934729 (MainThread): Parsing macros/catalog.sql
2021-12-02 20:53:13.939831 (MainThread): Parsing macros/relations.sql
2021-12-02 20:53:13.943083 (MainThread): Parsing macros/adapters.sql
2021-12-02 20:53:13.979053 (MainThread): Parsing macros/materializations/snapshot_merge.sql
2021-12-02 20:53:13.983027 (MainThread): Parsing macros/core.sql
2021-12-02 20:53:13.989269 (MainThread): Parsing macros/etc/datetime.sql
2021-12-02 20:53:14.003548 (MainThread): Parsing macros/etc/is_incremental.sql
2021-12-02 20:53:14.006928 (MainThread): Parsing macros/etc/get_custom_schema.sql
2021-12-02 20:53:14.011613 (MainThread): Parsing macros/etc/query.sql
2021-12-02 20:53:14.014206 (MainThread): Parsing macros/etc/where_subquery.sql
2021-12-02 20:53:14.017610 (MainThread): Parsing macros/etc/get_custom_alias.sql
2021-12-02 20:53:14.020917 (MainThread): Parsing macros/etc/get_custom_database.sql
2021-12-02 20:53:14.024153 (MainThread): Parsing macros/schema_tests/relationships.sql
2021-12-02 20:53:14.027408 (MainThread): Parsing macros/schema_tests/not_null.sql
2021-12-02 20:53:14.029804 (MainThread): Parsing macros/schema_tests/accepted_values.sql
2021-12-02 20:53:14.034029 (MainThread): Parsing macros/schema_tests/unique.sql
2021-12-02 20:53:14.037083 (MainThread): Parsing macros/materializations/helpers.sql
2021-12-02 20:53:14.053272 (MainThread): Parsing macros/materializations/test.sql
2021-12-02 20:53:14.064975 (MainThread): Parsing macros/materializations/seed/seed.sql
2021-12-02 20:53:14.101413 (MainThread): Parsing macros/materializations/snapshot/snapshot.sql
2021-12-02 20:53:14.156091 (MainThread): Parsing macros/materializations/snapshot/strategies.sql
2021-12-02 20:53:14.184095 (MainThread): Parsing macros/materializations/snapshot/snapshot_merge.sql
2021-12-02 20:53:14.188155 (MainThread): Parsing macros/materializations/common/merge.sql
2021-12-02 20:53:14.212079 (MainThread): Parsing macros/materializations/table/table.sql
2021-12-02 20:53:14.224583 (MainThread): Parsing macros/materializations/view/create_or_replace_view.sql
2021-12-02 20:53:14.231817 (MainThread): Parsing macros/materializations/view/view.sql
2021-12-02 20:53:14.243491 (MainThread): Parsing macros/materializations/incremental/on_schema_change.sql
2021-12-02 20:53:14.278088 (MainThread): Parsing macros/materializations/incremental/helpers.sql
2021-12-02 20:53:14.285024 (MainThread): Parsing macros/materializations/incremental/incremental.sql
2021-12-02 20:53:14.307559 (MainThread): Parsing macros/adapters/common.sql
2021-12-02 20:53:14.647590 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:14.668822 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:14.675771 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:14.682169 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:14.687602 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:14.694952 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:14.700797 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:14.706389 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:14.712205 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:14.718713 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:14.723848 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:14.729062 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:14.734458 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:14.794544 (MainThread): write_gpickle is deprecated and will be removed in 3.0.Use ``pickle.dump(G, path, protocol)``
2021-12-02 20:53:14.796779 (MainThread): Found 13 models, 0 tests, 0 snapshots, 0 analyses, 197 macros, 0 operations, 0 seed files, 0 sources, 0 exposures
2021-12-02 20:53:14.800698 (MainThread): 
2021-12-02 20:53:14.802350 (MainThread): Acquiring new redshift connection "master".
2021-12-02 20:53:14.805385 (ThreadPoolExecutor-0_0): Acquiring new redshift connection "list_integrationtests".
2021-12-02 20:53:14.820601 (ThreadPoolExecutor-0_0): Using redshift connection "list_integrationtests".
2021-12-02 20:53:14.822494 (ThreadPoolExecutor-0_0): On list_integrationtests: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "list_integrationtests"} */

    select distinct nspname from pg_namespace
  
2021-12-02 20:53:14.823858 (ThreadPoolExecutor-0_0): Opening a new connection, currently in state init
2021-12-02 20:53:14.825170 (ThreadPoolExecutor-0_0): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:16.035786 (ThreadPoolExecutor-0_0): SQL status: SELECT in 1.21 seconds
2021-12-02 20:53:16.044840 (ThreadPoolExecutor-0_0): On list_integrationtests: Close
2021-12-02 20:53:16.049800 (ThreadPoolExecutor-1_0): Acquiring new redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:53:16.061827 (ThreadPoolExecutor-1_0): Using redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:53:16.063458 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: BEGIN
2021-12-02 20:53:16.065269 (ThreadPoolExecutor-1_0): Opening a new connection, currently in state closed
2021-12-02 20:53:16.067225 (ThreadPoolExecutor-1_0): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:17.114081 (ThreadPoolExecutor-1_0): SQL status: BEGIN in 1.05 seconds
2021-12-02 20:53:17.116959 (ThreadPoolExecutor-1_0): Using redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:53:17.119402 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "list_integrationtests_test_dbt"} */
select
      'integrationtests' as database,
      tablename as name,
      schemaname as schema,
      'table' as type
    from pg_tables
    where schemaname ilike 'test_dbt'
    union all
    select
      'integrationtests' as database,
      viewname as name,
      schemaname as schema,
      'view' as type
    from pg_views
    where schemaname ilike 'test_dbt'
  
2021-12-02 20:53:17.262121 (ThreadPoolExecutor-1_0): SQL status: SELECT in 0.14 seconds
2021-12-02 20:53:17.267599 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: ROLLBACK
2021-12-02 20:53:17.417952 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: Close
2021-12-02 20:53:17.430280 (MainThread): Using redshift connection "master".
2021-12-02 20:53:17.432178 (MainThread): On master: BEGIN
2021-12-02 20:53:17.434221 (MainThread): Opening a new connection, currently in state init
2021-12-02 20:53:17.435718 (MainThread): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:18.565398 (MainThread): SQL status: BEGIN in 1.13 seconds
2021-12-02 20:53:18.568497 (MainThread): Using redshift connection "master".
2021-12-02 20:53:18.570695 (MainThread): On master: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "master"} */
with relation as (
        select
            pg_rewrite.ev_class as class,
            pg_rewrite.oid as id
        from pg_rewrite
    ),
    class as (
        select
            oid as id,
            relname as name,
            relnamespace as schema,
            relkind as kind
        from pg_class
    ),
    dependency as (
        select
            pg_depend.objid as id,
            pg_depend.refobjid as ref
        from pg_depend
    ),
    schema as (
        select
            pg_namespace.oid as id,
            pg_namespace.nspname as name
        from pg_namespace
        where nspname != 'information_schema' and nspname not like 'pg\_%'
    ),
    referenced as (
        select
            relation.id AS id,
            referenced_class.name ,
            referenced_class.schema ,
            referenced_class.kind
        from relation
        join class as referenced_class on relation.class=referenced_class.id
        where referenced_class.kind in ('r', 'v')
    ),
    relationships as (
        select
            referenced.name as referenced_name,
            referenced.schema as referenced_schema_id,
            dependent_class.name as dependent_name,
            dependent_class.schema as dependent_schema_id,
            referenced.kind as kind
        from referenced
        join dependency on referenced.id=dependency.id
        join class as dependent_class on dependency.ref=dependent_class.id
        where
            (referenced.name != dependent_class.name or
             referenced.schema != dependent_class.schema)
    )

    select
        referenced_schema.name as referenced_schema,
        relationships.referenced_name as referenced_name,
        dependent_schema.name as dependent_schema,
        relationships.dependent_name as dependent_name
    from relationships
    join schema as dependent_schema on relationships.dependent_schema_id=dependent_schema.id
    join schema as referenced_schema on relationships.referenced_schema_id=referenced_schema.id
    group by referenced_schema, referenced_name, dependent_schema, dependent_name
    order by referenced_schema, referenced_name, dependent_schema, dependent_name;
2021-12-02 20:53:19.811824 (MainThread): SQL status: SELECT in 1.24 seconds
2021-12-02 20:53:19.838202 (MainThread): On master: ROLLBACK
2021-12-02 20:53:19.950659 (MainThread): Using redshift connection "master".
2021-12-02 20:53:19.954024 (MainThread): On master: BEGIN
2021-12-02 20:53:20.158803 (MainThread): SQL status: BEGIN in 0.20 seconds
2021-12-02 20:53:20.162250 (MainThread): On master: COMMIT
2021-12-02 20:53:20.164412 (MainThread): Using redshift connection "master".
2021-12-02 20:53:20.166343 (MainThread): On master: COMMIT
2021-12-02 20:53:20.269759 (MainThread): SQL status: COMMIT in 0.10 seconds
2021-12-02 20:53:20.273371 (MainThread): On master: Close
2021-12-02 20:53:20.275967 (MainThread): 20:53:20 | Concurrency: 32 threads (target='prod')
2021-12-02 20:53:20.278539 (MainThread): 20:53:20 | 
2021-12-02 20:53:20.300019 (Thread-1): Began running node model.incremental_test_schema_change.change_column_names
2021-12-02 20:53:20.300694 (Thread-2): Began running node model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:53:20.301021 (Thread-3): Began running node model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:53:20.301591 (Thread-4): Began running node model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:53:20.302280 (Thread-5): Began running node model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:53:20.302696 (Thread-6): Began running node model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:53:20.314010 (Thread-6): 20:53:20 | 6 of 13 START incremental model test_dbt.convert_column_float_to_int......................................... [RUN]
2021-12-02 20:53:20.303483 (Thread-7): Began running node model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:53:20.303848 (Thread-8): Began running node model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:53:20.304609 (Thread-9): Began running node model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:53:20.305225 (Thread-10): Began running node model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:53:20.305860 (Thread-2): 20:53:20 | 2 of 13 START incremental model test_dbt.convert_column_boolean_to_float..................................... [RUN]
2021-12-02 20:53:20.325843 (Thread-2): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:20.306421 (Thread-12): Began running node model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:53:20.307047 (Thread-13): Began running node model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:53:20.308611 (Thread-3): 20:53:20 | 3 of 13 START incremental model test_dbt.convert_column_boolean_to_int....................................... [RUN]
2021-12-02 20:53:20.310481 (Thread-4): 20:53:20 | 4 of 13 START incremental model test_dbt.convert_column_boolean_to_string.................................... [RUN]
2021-12-02 20:53:20.312225 (Thread-5): 20:53:20 | 5 of 13 START incremental model test_dbt.convert_column_float_to_boolean..................................... [RUN]
2021-12-02 20:53:20.303095 (Thread-1): 20:53:20 | 1 of 13 START incremental model test_dbt.change_column_names................................................. [RUN]
2021-12-02 20:53:20.316408 (Thread-6): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:20.318348 (Thread-7): 20:53:20 | 7 of 13 START incremental model test_dbt.convert_column_float_to_string...................................... [RUN]
2021-12-02 20:53:20.320200 (Thread-8): 20:53:20 | 8 of 13 START incremental model test_dbt.convert_column_int_to_boolean....................................... [RUN]
2021-12-02 20:53:20.321862 (Thread-9): 20:53:20 | 9 of 13 START incremental model test_dbt.convert_column_int_to_float......................................... [RUN]
2021-12-02 20:53:20.323802 (Thread-10): 20:53:20 | 10 of 13 START incremental model test_dbt.convert_column_int_to_string....................................... [RUN]
2021-12-02 20:53:20.306079 (Thread-11): Began running node model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:53:20.327642 (Thread-2): Compiling model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:53:20.329225 (Thread-12): 20:53:20 | 12 of 13 START incremental model test_dbt.convert_column_string_to_float..................................... [RUN]
2021-12-02 20:53:20.330841 (Thread-13): 20:53:20 | 13 of 13 START incremental model test_dbt.convert_column_string_to_int....................................... [RUN]
2021-12-02 20:53:20.333523 (Thread-3): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:20.334969 (Thread-4): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:20.336984 (Thread-5): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:20.338904 (Thread-1): Acquiring new redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:20.339782 (Thread-6): Compiling model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:53:20.342266 (Thread-7): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:20.343924 (Thread-8): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:20.345525 (Thread-9): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:20.347437 (Thread-10): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:20.348856 (Thread-11): 20:53:20 | 11 of 13 START incremental model test_dbt.convert_column_string_to_boolean................................... [RUN]
2021-12-02 20:53:20.352582 (Thread-2): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_float"
2021-12-02 20:53:20.354036 (Thread-12): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:20.355750 (Thread-13): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:20.357382 (Thread-3): Compiling model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:53:20.358624 (Thread-4): Compiling model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:53:20.359705 (Thread-5): Compiling model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:53:20.360909 (Thread-1): Compiling model.incremental_test_schema_change.change_column_names
2021-12-02 20:53:20.365234 (Thread-6): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_int"
2021-12-02 20:53:20.366686 (Thread-7): Compiling model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:53:20.367835 (Thread-8): Compiling model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:53:20.369198 (Thread-9): Compiling model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:53:20.370641 (Thread-10): Compiling model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:53:20.372384 (Thread-11): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:20.374591 (Thread-12): Compiling model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:53:20.375824 (Thread-13): Compiling model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:53:20.380048 (Thread-3): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_int"
2021-12-02 20:53:20.384233 (Thread-4): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_string"
2021-12-02 20:53:20.388532 (Thread-5): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_boolean"
2021-12-02 20:53:20.393318 (Thread-1): Writing injected SQL for node "model.incremental_test_schema_change.change_column_names"
2021-12-02 20:53:20.398379 (Thread-7): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_string"
2021-12-02 20:53:20.399471 (Thread-2): finished collecting timing info
2021-12-02 20:53:20.402634 (Thread-8): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_boolean"
2021-12-02 20:53:20.403479 (Thread-6): finished collecting timing info
2021-12-02 20:53:20.406465 (Thread-9): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_float"
2021-12-02 20:53:20.409696 (Thread-10): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_string"
2021-12-02 20:53:20.410987 (Thread-11): Compiling model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:53:20.416565 (Thread-12): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_float"
2021-12-02 20:53:20.420377 (Thread-13): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_int"
2021-12-02 20:53:20.425757 (Thread-3): finished collecting timing info
2021-12-02 20:53:20.427996 (Thread-4): finished collecting timing info
2021-12-02 20:53:20.446600 (Thread-1): finished collecting timing info
2021-12-02 20:53:20.457981 (Thread-5): finished collecting timing info
2021-12-02 20:53:20.458469 (Thread-7): finished collecting timing info
2021-12-02 20:53:20.500610 (Thread-8): finished collecting timing info
2021-12-02 20:53:20.524177 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:20.526641 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:20.527051 (Thread-10): finished collecting timing info
2021-12-02 20:53:20.530596 (Thread-11): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_boolean"
2021-12-02 20:53:20.530896 (Thread-9): finished collecting timing info
2021-12-02 20:53:20.538575 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:20.539709 (Thread-12): finished collecting timing info
2021-12-02 20:53:20.540380 (Thread-13): finished collecting timing info
2021-12-02 20:53:20.543795 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:20.548183 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:20.552427 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:20.556579 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:20.560887 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:20.562222 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

    

  create temporary table
    "convert_column_boolean_to_float__dbt_tmp205320475354"
    
    
  as (
    select
    2.2 as column_boolean_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.563336 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

    

  create temporary table
    "convert_column_float_to_int__dbt_tmp205320479364"
    
    
  as (
    select
    2 as column_float_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.567646 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:20.573188 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:20.574224 (Thread-11): finished collecting timing info
2021-12-02 20:53:20.574534 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

    

  create temporary table
    "convert_column_boolean_to_int__dbt_tmp205320537164"
    
    
  as (
    select
    2 as column_boolean_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.579725 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:20.584194 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:20.585508 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

    

  create temporary table
    "convert_column_boolean_to_string__dbt_tmp205320542442"
    
    
  as (
    select
    'false' as column_boolean_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.586790 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

    

  create temporary table
    "change_column_names__dbt_tmp205320546899"
    
    
  as (
    select
    'replacing underscore with space' as "new column name",
    'a renamed column' as renamed_column,
    'a new column is added' as new_column,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.588123 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

    

  create temporary table
    "convert_column_float_to_boolean__dbt_tmp205320551077"
    
    
  as (
    select
    false as column_float_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.589392 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

    

  create temporary table
    "convert_column_float_to_string__dbt_tmp205320555306"
    
    
  as (
    select
    '2.2' as column_float_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.590655 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

    

  create temporary table
    "convert_column_int_to_boolean__dbt_tmp205320559610"
    
    
  as (
    select
    false as column_int_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.591995 (Thread-2): Opening a new connection, currently in state init
2021-12-02 20:53:20.593066 (Thread-6): Opening a new connection, currently in state init
2021-12-02 20:53:20.594347 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

    

  create temporary table
    "convert_column_int_to_string__dbt_tmp205320566301"
    
    
  as (
    select
    '2' as column_int_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.595487 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

    

  create temporary table
    "convert_column_int_to_float__dbt_tmp205320571814"
    
    
  as (
    select
    2.2 as column_int_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.599950 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:20.602175 (Thread-3): Opening a new connection, currently in state init
2021-12-02 20:53:20.603313 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

    

  create temporary table
    "convert_column_string_to_float__dbt_tmp205320578419"
    
    
  as (
    select
    2.2 as column_string_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.604712 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

    

  create temporary table
    "convert_column_string_to_int__dbt_tmp205320582755"
    
    
  as (
    select
    2 as column_string_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.605902 (Thread-4): Opening a new connection, currently in state init
2021-12-02 20:53:20.607345 (Thread-1): Opening a new connection, currently in state closed
2021-12-02 20:53:20.608584 (Thread-5): Opening a new connection, currently in state init
2021-12-02 20:53:20.609831 (Thread-7): Opening a new connection, currently in state init
2021-12-02 20:53:20.610976 (Thread-8): Opening a new connection, currently in state init
2021-12-02 20:53:20.612205 (Thread-2): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.613468 (Thread-6): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.614903 (Thread-10): Opening a new connection, currently in state init
2021-12-02 20:53:20.616613 (Thread-9): Opening a new connection, currently in state init
2021-12-02 20:53:20.617774 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

    

  create temporary table
    "convert_column_string_to_boolean__dbt_tmp205320598539"
    
    
  as (
    select
    false as column_string_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:53:20.618961 (Thread-3): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.620263 (Thread-12): Opening a new connection, currently in state init
2021-12-02 20:53:20.640383 (Thread-12): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.622951 (Thread-4): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.624368 (Thread-1): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.625523 (Thread-5): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.626739 (Thread-7): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.627892 (Thread-8): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.632522 (Thread-10): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.634565 (Thread-9): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.636482 (Thread-11): Opening a new connection, currently in state init
2021-12-02 20:53:20.621504 (Thread-13): Opening a new connection, currently in state init
2021-12-02 20:53:20.654945 (Thread-11): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:20.657009 (Thread-13): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:21.867725 (Thread-10): SQL status: SELECT in 1.25 seconds
2021-12-02 20:53:21.868368 (Thread-8): SQL status: SELECT in 1.26 seconds
2021-12-02 20:53:21.870260 (Thread-12): SQL status: SELECT in 1.25 seconds
2021-12-02 20:53:21.894890 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:21.876952 (Thread-6): SQL status: SELECT in 1.28 seconds
2021-12-02 20:53:21.884016 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:21.889006 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:21.903931 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: BEGIN
2021-12-02 20:53:21.896425 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: BEGIN
2021-12-02 20:53:21.900981 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:21.902562 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: BEGIN
2021-12-02 20:53:21.870610 (Thread-13): SQL status: SELECT in 1.25 seconds
2021-12-02 20:53:21.908611 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: BEGIN
2021-12-02 20:53:21.914668 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:21.917465 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: BEGIN
2021-12-02 20:53:22.002737 (Thread-8): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:53:22.006287 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:22.008482 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean__dbt_tmp205320559610'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean__dbt_tmp205320559610'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_boolean__dbt_tmp205320559610'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.010222 (Thread-10): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:53:22.010693 (Thread-12): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:53:22.013013 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:22.014671 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:22.016423 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string__dbt_tmp205320566301'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string__dbt_tmp205320566301'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_string__dbt_tmp205320566301'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.017040 (Thread-5): SQL status: SELECT in 1.41 seconds
2021-12-02 20:53:22.018053 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float__dbt_tmp205320578419'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float__dbt_tmp205320578419'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_float__dbt_tmp205320578419'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.025348 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:22.025751 (Thread-13): SQL status: BEGIN in 0.11 seconds
2021-12-02 20:53:22.027352 (Thread-6): SQL status: BEGIN in 0.11 seconds
2021-12-02 20:53:22.027931 (Thread-3): SQL status: SELECT in 1.43 seconds
2021-12-02 20:53:22.029662 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: BEGIN
2021-12-02 20:53:22.031067 (Thread-11): SQL status: SELECT in 1.39 seconds
2021-12-02 20:53:22.031419 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:22.033067 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:22.047511 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int__dbt_tmp205320479364'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int__dbt_tmp205320479364'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_int__dbt_tmp205320479364'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.039942 (Thread-4): SQL status: SELECT in 1.43 seconds
2021-12-02 20:53:22.044023 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:22.045772 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int__dbt_tmp205320582755'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int__dbt_tmp205320582755'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_int__dbt_tmp205320582755'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.037692 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:22.050621 (Thread-2): SQL status: SELECT in 1.46 seconds
2021-12-02 20:53:22.063292 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:22.054568 (Thread-1): SQL status: SELECT in 1.45 seconds
2021-12-02 20:53:22.055963 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: BEGIN
2021-12-02 20:53:22.059440 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: BEGIN
2021-12-02 20:53:22.054352 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:22.065474 (Thread-9): SQL status: SELECT in 1.45 seconds
2021-12-02 20:53:22.065684 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: BEGIN
2021-12-02 20:53:22.065979 (Thread-7): SQL status: SELECT in 1.46 seconds
2021-12-02 20:53:22.069566 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:22.073183 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: BEGIN
2021-12-02 20:53:22.076496 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:22.084875 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: BEGIN
2021-12-02 20:53:22.082322 (Thread-1): On model.incremental_test_schema_change.change_column_names: BEGIN
2021-12-02 20:53:22.080959 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:22.088391 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: BEGIN
2021-12-02 20:53:22.143521 (Thread-5): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:53:22.145957 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:22.147906 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean__dbt_tmp205320551077'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean__dbt_tmp205320551077'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_boolean__dbt_tmp205320551077'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.188107 (Thread-11): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:53:22.191359 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:22.192990 (Thread-3): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:53:22.193493 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean__dbt_tmp205320598539'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean__dbt_tmp205320598539'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_boolean__dbt_tmp205320598539'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.193816 (Thread-2): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:53:22.199964 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:22.196002 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:22.201496 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float__dbt_tmp205320475354'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float__dbt_tmp205320475354'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_float__dbt_tmp205320475354'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.203193 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int__dbt_tmp205320537164'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int__dbt_tmp205320537164'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_int__dbt_tmp205320537164'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.219460 (Thread-7): SQL status: BEGIN in 0.13 seconds
2021-12-02 20:53:22.220216 (Thread-4): SQL status: BEGIN in 0.14 seconds
2021-12-02 20:53:22.221443 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:22.224847 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string__dbt_tmp205320555306'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string__dbt_tmp205320555306'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_string__dbt_tmp205320555306'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.222813 (Thread-1): SQL status: BEGIN in 0.14 seconds
2021-12-02 20:53:22.223215 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:22.222504 (Thread-9): SQL status: BEGIN in 0.14 seconds
2021-12-02 20:53:22.228467 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:22.229805 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string__dbt_tmp205320542442'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string__dbt_tmp205320542442'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_string__dbt_tmp205320542442'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.231304 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:22.232894 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names__dbt_tmp205320546899'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names__dbt_tmp205320546899'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'change_column_names__dbt_tmp205320546899'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:22.236284 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float__dbt_tmp205320571814'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float__dbt_tmp205320571814'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_float__dbt_tmp205320571814'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:34.372603 (Thread-5): SQL status: SELECT in 12.22 seconds
2021-12-02 20:53:34.373293 (Thread-4): SQL status: SELECT in 12.14 seconds
2021-12-02 20:53:34.384385 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:34.388878 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:34.390976 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.392854 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.405037 (Thread-7): SQL status: SELECT in 12.18 seconds
2021-12-02 20:53:34.410244 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:34.410522 (Thread-3): SQL status: SELECT in 12.20 seconds
2021-12-02 20:53:34.412304 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.417024 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:34.420848 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.439264 (Thread-8): SQL status: SELECT in 12.43 seconds
2021-12-02 20:53:34.444349 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:34.445934 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.452392 (Thread-12): SQL status: SELECT in 12.42 seconds
2021-12-02 20:53:34.455784 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:34.456765 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.457170 (Thread-6): SQL status: SELECT in 12.41 seconds
2021-12-02 20:53:34.461681 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:34.462868 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.474620 (Thread-2): SQL status: SELECT in 12.27 seconds
2021-12-02 20:53:34.478296 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:34.478498 (Thread-11): SQL status: SELECT in 12.28 seconds
2021-12-02 20:53:34.479530 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.483201 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:34.485825 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.494809 (Thread-10): SQL status: SELECT in 12.47 seconds
2021-12-02 20:53:34.498478 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:34.499664 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.512364 (Thread-13): SQL status: SELECT in 12.45 seconds
2021-12-02 20:53:34.517413 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:34.519175 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.535573 (Thread-9): SQL status: SELECT in 12.30 seconds
2021-12-02 20:53:34.536338 (Thread-1): SQL status: SELECT in 12.30 seconds
2021-12-02 20:53:34.584410 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:34.589842 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:34.593624 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'change_column_names'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:34.591725 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:46.127249 (Thread-3): SQL status: SELECT in 11.70 seconds
2021-12-02 20:53:46.128148 (Thread-11): SQL status: SELECT in 11.64 seconds
2021-12-02 20:53:46.128992 (Thread-4): SQL status: SELECT in 11.73 seconds
2021-12-02 20:53:46.129261 (Thread-7): SQL status: SELECT in 11.71 seconds
2021-12-02 20:53:46.129708 (Thread-5): SQL status: SELECT in 11.73 seconds
2021-12-02 20:53:46.165511 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:46.175200 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:46.178843 (Thread-1): SQL status: SELECT in 11.58 seconds
2021-12-02 20:53:46.178661 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:46.200520 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean__dbt_tmp205320598539'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean__dbt_tmp205320598539'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_boolean__dbt_tmp205320598539'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.184732 (Thread-13): SQL status: SELECT in 11.66 seconds
2021-12-02 20:53:46.206741 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:46.191607 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int__dbt_tmp205320537164'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int__dbt_tmp205320537164'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_int__dbt_tmp205320537164'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.193603 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string__dbt_tmp205320542442'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string__dbt_tmp205320542442'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_string__dbt_tmp205320542442'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.198891 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:46.199327 (Thread-6): SQL status: SELECT in 11.73 seconds
2021-12-02 20:53:46.199658 (Thread-2): SQL status: SELECT in 11.71 seconds
2021-12-02 20:53:46.184211 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:46.189914 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:46.208047 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int__dbt_tmp205320582755'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int__dbt_tmp205320582755'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_int__dbt_tmp205320582755'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.213153 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names__dbt_tmp205320546899'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names__dbt_tmp205320546899'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'change_column_names__dbt_tmp205320546899'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.217181 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:46.217556 (Thread-12): SQL status: SELECT in 11.76 seconds
2021-12-02 20:53:46.220865 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:46.221872 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string__dbt_tmp205320555306'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string__dbt_tmp205320555306'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_string__dbt_tmp205320555306'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.223105 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean__dbt_tmp205320551077'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean__dbt_tmp205320551077'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_boolean__dbt_tmp205320551077'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.227781 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int__dbt_tmp205320479364'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int__dbt_tmp205320479364'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_int__dbt_tmp205320479364'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.232972 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:46.233202 (Thread-8): SQL status: SELECT in 11.79 seconds
2021-12-02 20:53:46.233389 (Thread-10): SQL status: SELECT in 11.73 seconds
2021-12-02 20:53:46.234940 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float__dbt_tmp205320475354'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float__dbt_tmp205320475354'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_float__dbt_tmp205320475354'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.240501 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float__dbt_tmp205320578419'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float__dbt_tmp205320578419'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_float__dbt_tmp205320578419'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.244223 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:46.247907 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:46.252170 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean__dbt_tmp205320559610'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean__dbt_tmp205320559610'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_boolean__dbt_tmp205320559610'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.253583 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string__dbt_tmp205320566301'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string__dbt_tmp205320566301'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_string__dbt_tmp205320566301'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:46.256684 (Thread-9): SQL status: SELECT in 11.66 seconds
2021-12-02 20:53:46.261008 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:46.262061 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float__dbt_tmp205320571814'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float__dbt_tmp205320571814'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_float__dbt_tmp205320571814'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:53:58.019628 (Thread-4): SQL status: SELECT in 11.81 seconds
2021-12-02 20:53:58.020251 (Thread-12): SQL status: SELECT in 11.77 seconds
2021-12-02 20:53:58.027685 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:58.032504 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:58.034372 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.036168 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.065609 (Thread-9): SQL status: SELECT in 11.80 seconds
2021-12-02 20:53:58.072069 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:58.072400 (Thread-13): SQL status: SELECT in 11.85 seconds
2021-12-02 20:53:58.074110 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.074460 (Thread-11): SQL status: SELECT in 11.87 seconds
2021-12-02 20:53:58.078570 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:58.081045 (Thread-2): SQL status: SELECT in 11.83 seconds
2021-12-02 20:53:58.082452 (Thread-10): SQL status: SELECT in 11.83 seconds
2021-12-02 20:53:58.085948 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:58.087577 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.092221 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:58.096762 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:58.097215 (Thread-1): SQL status: SELECT in 11.87 seconds
2021-12-02 20:53:58.107037 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:58.097664 (Thread-7): SQL status: SELECT in 11.86 seconds
2021-12-02 20:53:58.098677 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.101991 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.103425 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.097478 (Thread-5): SQL status: SELECT in 11.86 seconds
2021-12-02 20:53:58.108131 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'change_column_names'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.111665 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:58.121587 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:58.121844 (Thread-6): SQL status: SELECT in 11.88 seconds
2021-12-02 20:53:58.122085 (Thread-8): SQL status: SELECT in 11.87 seconds
2021-12-02 20:53:58.133265 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:58.126023 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.129580 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:58.129836 (Thread-3): SQL status: SELECT in 11.92 seconds
2021-12-02 20:53:58.124855 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.134522 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.137424 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:58.140924 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:58.146070 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.131357 (Thread-9): SQL status: SELECT in 12.05 seconds
2021-12-02 20:54:10.149115 (Thread-7): SQL status: SELECT in 12.01 seconds
2021-12-02 20:54:10.150731 (Thread-9): 
    In "integrationtests"."test_dbt"."convert_column_int_to_float":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_int_to_float', 'new_type': 'numeric(2,1)'}]
  
2021-12-02 20:54:10.154019 (Thread-7): 
    In "integrationtests"."test_dbt"."convert_column_float_to_string":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_float_to_string', 'new_type': 'character varying(3)'}]
  
2021-12-02 20:54:10.154319 (Thread-4): SQL status: SELECT in 12.12 seconds
2021-12-02 20:54:10.154623 (Thread-11): SQL status: SELECT in 12.04 seconds
2021-12-02 20:54:10.179560 (Thread-5): SQL status: SELECT in 12.04 seconds
2021-12-02 20:54:10.181141 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:54:10.184447 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:54:10.188736 (Thread-4): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_string":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_boolean_to_string', 'new_type': 'character varying(5)'}]
  
2021-12-02 20:54:10.193156 (Thread-12): SQL status: SELECT in 12.15 seconds
2021-12-02 20:54:10.192811 (Thread-11): 
    In "integrationtests"."test_dbt"."convert_column_string_to_boolean":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_string_to_boolean', 'new_type': 'boolean'}]
  
2021-12-02 20:54:10.196087 (Thread-5): 
    In "integrationtests"."test_dbt"."convert_column_float_to_boolean":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_float_to_boolean', 'new_type': 'boolean'}]
  
2021-12-02 20:54:10.197677 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

    alter table "integrationtests"."test_dbt"."convert_column_float_to_string" add column "column_float_to_string__dbt_alter" character varying(3);
    update "integrationtests"."test_dbt"."convert_column_float_to_string" set "column_float_to_string__dbt_alter" = "column_float_to_string";
    alter table "integrationtests"."test_dbt"."convert_column_float_to_string" drop column "column_float_to_string" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_float_to_string" rename column "column_float_to_string__dbt_alter" to "column_float_to_string"
  
2021-12-02 20:54:10.198853 (Thread-6): SQL status: SELECT in 12.05 seconds
2021-12-02 20:54:10.199759 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

    alter table "integrationtests"."test_dbt"."convert_column_int_to_float" add column "column_int_to_float__dbt_alter" numeric(2,1);
    update "integrationtests"."test_dbt"."convert_column_int_to_float" set "column_int_to_float__dbt_alter" = "column_int_to_float";
    alter table "integrationtests"."test_dbt"."convert_column_int_to_float" drop column "column_int_to_float" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_int_to_float" rename column "column_int_to_float__dbt_alter" to "column_int_to_float"
  
2021-12-02 20:54:10.200592 (Thread-8): SQL status: SELECT in 12.06 seconds
2021-12-02 20:54:10.202221 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:54:10.218038 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_string" add column "column_boolean_to_string__dbt_alter" character varying(5);
    update "integrationtests"."test_dbt"."convert_column_boolean_to_string" set "column_boolean_to_string__dbt_alter" = "column_boolean_to_string";
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_string" drop column "column_boolean_to_string" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_string" rename column "column_boolean_to_string__dbt_alter" to "column_boolean_to_string"
  
2021-12-02 20:54:10.206688 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:54:10.208476 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:54:10.212866 (Thread-6): 
    In "integrationtests"."test_dbt"."convert_column_float_to_int":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_float_to_int', 'new_type': 'integer'}]
  
2021-12-02 20:54:10.216687 (Thread-8): 
    In "integrationtests"."test_dbt"."convert_column_int_to_boolean":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_int_to_boolean', 'new_type': 'boolean'}]
  
2021-12-02 20:54:10.216884 (Thread-13): SQL status: SELECT in 12.12 seconds
2021-12-02 20:54:10.228335 (Thread-13): 
    In "integrationtests"."test_dbt"."convert_column_string_to_int":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_string_to_int', 'new_type': 'integer'}]
  
2021-12-02 20:54:10.220256 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

    alter table "integrationtests"."test_dbt"."convert_column_string_to_boolean" add column "column_string_to_boolean__dbt_alter" boolean;
    update "integrationtests"."test_dbt"."convert_column_string_to_boolean" set "column_string_to_boolean__dbt_alter" = "column_string_to_boolean";
    alter table "integrationtests"."test_dbt"."convert_column_string_to_boolean" drop column "column_string_to_boolean" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_string_to_boolean" rename column "column_string_to_boolean__dbt_alter" to "column_string_to_boolean"
  
2021-12-02 20:54:10.220439 (Thread-2): SQL status: SELECT in 12.11 seconds
2021-12-02 20:54:10.234197 (Thread-2): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_float":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_boolean_to_float', 'new_type': 'numeric(2,1)'}]
  
2021-12-02 20:54:10.223563 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:54:10.225268 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:54:10.205050 (Thread-12): 
    In "integrationtests"."test_dbt"."convert_column_string_to_float":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_string_to_float', 'new_type': 'numeric(2,1)'}]
  
2021-12-02 20:54:10.239850 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:54:10.240968 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

    alter table "integrationtests"."test_dbt"."convert_column_string_to_float" add column "column_string_to_float__dbt_alter" numeric(2,1);
    update "integrationtests"."test_dbt"."convert_column_string_to_float" set "column_string_to_float__dbt_alter" = "column_string_to_float";
    alter table "integrationtests"."test_dbt"."convert_column_string_to_float" drop column "column_string_to_float" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_string_to_float" rename column "column_string_to_float__dbt_alter" to "column_string_to_float"
  
2021-12-02 20:54:10.234404 (Thread-10): SQL status: SELECT in 12.12 seconds
2021-12-02 20:54:10.235805 (Thread-2): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:54:10.237055 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

    alter table "integrationtests"."test_dbt"."convert_column_float_to_int" add column "column_float_to_int__dbt_alter" integer;
    update "integrationtests"."test_dbt"."convert_column_float_to_int" set "column_float_to_int__dbt_alter" = "column_float_to_int";
    alter table "integrationtests"."test_dbt"."convert_column_float_to_int" drop column "column_float_to_int" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_float_to_int" rename column "column_float_to_int__dbt_alter" to "column_float_to_int"
  
2021-12-02 20:54:10.238330 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

    alter table "integrationtests"."test_dbt"."convert_column_int_to_boolean" add column "column_int_to_boolean__dbt_alter" boolean;
    update "integrationtests"."test_dbt"."convert_column_int_to_boolean" set "column_int_to_boolean__dbt_alter" = "column_int_to_boolean";
    alter table "integrationtests"."test_dbt"."convert_column_int_to_boolean" drop column "column_int_to_boolean" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_int_to_boolean" rename column "column_int_to_boolean__dbt_alter" to "column_int_to_boolean"
  
2021-12-02 20:54:10.238594 (Thread-3): SQL status: SELECT in 12.09 seconds
2021-12-02 20:54:10.230145 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:54:10.251688 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

    alter table "integrationtests"."test_dbt"."convert_column_string_to_int" add column "column_string_to_int__dbt_alter" integer;
    update "integrationtests"."test_dbt"."convert_column_string_to_int" set "column_string_to_int__dbt_alter" = "column_string_to_int";
    alter table "integrationtests"."test_dbt"."convert_column_string_to_int" drop column "column_string_to_int" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_string_to_int" rename column "column_string_to_int__dbt_alter" to "column_string_to_int"
  
2021-12-02 20:54:10.244321 (Thread-10): 
    In "integrationtests"."test_dbt"."convert_column_int_to_string":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_int_to_string', 'new_type': 'character varying(1)'}]
  
2021-12-02 20:54:10.245597 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_float" add column "column_boolean_to_float__dbt_alter" numeric(2,1);
    update "integrationtests"."test_dbt"."convert_column_boolean_to_float" set "column_boolean_to_float__dbt_alter" = "column_boolean_to_float";
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_float" drop column "column_boolean_to_float" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_float" rename column "column_boolean_to_float__dbt_alter" to "column_boolean_to_float"
  
2021-12-02 20:54:10.250551 (Thread-3): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_int":
        Schema changed: True
        Source columns not in target: []
        Target columns not in source: []
        New column types: [{'column_name': 'column_boolean_to_int', 'new_type': 'integer'}]
  
2021-12-02 20:54:10.221650 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

    alter table "integrationtests"."test_dbt"."convert_column_float_to_boolean" add column "column_float_to_boolean__dbt_alter" boolean;
    update "integrationtests"."test_dbt"."convert_column_float_to_boolean" set "column_float_to_boolean__dbt_alter" = "column_float_to_boolean";
    alter table "integrationtests"."test_dbt"."convert_column_float_to_boolean" drop column "column_float_to_boolean" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_float_to_boolean" rename column "column_float_to_boolean__dbt_alter" to "column_float_to_boolean"
  
2021-12-02 20:54:10.254723 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:54:10.257616 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:54:10.258628 (Thread-1): SQL status: SELECT in 12.14 seconds
2021-12-02 20:54:10.260726 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

    alter table "integrationtests"."test_dbt"."convert_column_int_to_string" add column "column_int_to_string__dbt_alter" character varying(1);
    update "integrationtests"."test_dbt"."convert_column_int_to_string" set "column_int_to_string__dbt_alter" = "column_int_to_string";
    alter table "integrationtests"."test_dbt"."convert_column_int_to_string" drop column "column_int_to_string" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_int_to_string" rename column "column_int_to_string__dbt_alter" to "column_int_to_string"
  
2021-12-02 20:54:10.261900 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_int" add column "column_boolean_to_int__dbt_alter" integer;
    update "integrationtests"."test_dbt"."convert_column_boolean_to_int" set "column_boolean_to_int__dbt_alter" = "column_boolean_to_int";
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_int" drop column "column_boolean_to_int" cascade;
    alter table "integrationtests"."test_dbt"."convert_column_boolean_to_int" rename column "column_boolean_to_int__dbt_alter" to "column_boolean_to_int"
  
2021-12-02 20:54:10.264597 (Thread-1): 
    In "integrationtests"."test_dbt"."change_column_names":
        Schema changed: True
        Source columns not in target: [<Column new column name (character varying(31))>, <Column renamed_column (character varying(16))>, <Column new_column (character varying(21))>]
        Target columns not in source: [<Column column_name (character varying(24))>, <Column column_to_rename (character varying(18))>, <Column column_to_delete (character varying(22))>]
        New column types: []
  
2021-12-02 20:54:10.275325 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:54:10.276916 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

    alter table "integrationtests"."test_dbt"."change_column_names" add column new column name character varying(31)
      
  
2021-12-02 20:54:10.459265 (Thread-7): SQL status: ALTER TABLE in 0.25 seconds
2021-12-02 20:54:10.463341 (Thread-7): 
    In "integrationtests"."test_dbt"."convert_column_float_to_string":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_float_to_string', 'new_type': 'character varying(3)'}]
  
2021-12-02 20:54:10.463674 (Thread-1): Postgres error: syntax error at or near "new"
LINE 3: ...ests"."test_dbt"."change_column_names" add column new column...
                                                             ^

2021-12-02 20:54:10.472926 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:54:10.474160 (Thread-1): On model.incremental_test_schema_change.change_column_names: ROLLBACK
2021-12-02 20:54:10.474733 (Thread-11): Postgres error: column "column_string_to_boolean__dbt_alter" is of type boolean but expression is of type character varying
HINT:  You will need to rewrite or cast the expression.

2021-12-02 20:54:10.479441 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: ROLLBACK
2021-12-02 20:54:10.475944 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.540214 (Thread-5): Postgres error: column "column_float_to_boolean__dbt_alter" is of type boolean but expression is of type numeric
HINT:  You will need to rewrite or cast the expression.

2021-12-02 20:54:10.540895 (Thread-13): Postgres error: column "column_string_to_int__dbt_alter" is of type integer but expression is of type character varying
HINT:  You will need to rewrite or cast the expression.

2021-12-02 20:54:10.543339 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: ROLLBACK
2021-12-02 20:54:10.545696 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: ROLLBACK
2021-12-02 20:54:10.579010 (Thread-2): Postgres error: column "column_boolean_to_float__dbt_alter" is of type numeric but expression is of type boolean
HINT:  You will need to rewrite or cast the expression.

2021-12-02 20:54:10.582232 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: ROLLBACK
2021-12-02 20:54:10.600679 (Thread-12): SQL status: ALTER TABLE in 0.36 seconds
2021-12-02 20:54:10.601099 (Thread-6): SQL status: ALTER TABLE in 0.35 seconds
2021-12-02 20:54:10.604164 (Thread-12): 
    In "integrationtests"."test_dbt"."convert_column_string_to_float":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_string_to_float', 'new_type': 'numeric(2,1)'}]
  
2021-12-02 20:54:10.604642 (Thread-11): finished collecting timing info
2021-12-02 20:54:10.612295 (Thread-11): On model.incremental_test_schema_change.convert_column_string_to_boolean: Close
2021-12-02 20:54:10.610744 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:54:10.606874 (Thread-6): 
    In "integrationtests"."test_dbt"."convert_column_float_to_int":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_float_to_int', 'new_type': 'integer'}]
  
2021-12-02 20:54:10.612718 (Thread-1): finished collecting timing info
2021-12-02 20:54:10.614217 (Thread-11): Database Error in model convert_column_string_to_boolean (models/change_column_types/convert_column_string_to_boolean.sql)
  column "column_string_to_boolean__dbt_alter" is of type boolean but expression is of type character varying
  HINT:  You will need to rewrite or cast the expression.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.DatatypeMismatch: column "column_string_to_boolean__dbt_alter" is of type boolean but expression is of type character varying
HINT:  You will need to rewrite or cast the expression.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 63, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 55, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model convert_column_string_to_boolean (models/change_column_types/convert_column_string_to_boolean.sql)
  column "column_string_to_boolean__dbt_alter" is of type boolean but expression is of type character varying
  HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:10.616921 (Thread-9): SQL status: ALTER TABLE in 0.40 seconds
2021-12-02 20:54:10.617115 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.620797 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:54:10.621069 (Thread-3): SQL status: ALTER TABLE in 0.35 seconds
2021-12-02 20:54:10.622657 (Thread-1): On model.incremental_test_schema_change.change_column_names: Close
2021-12-02 20:54:10.625117 (Thread-11): 20:54:10 | 11 of 13 ERROR creating incremental model test_dbt.convert_column_string_to_boolean.......................... [ERROR in 50.25s]
2021-12-02 20:54:10.636382 (Thread-11): Finished running node model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:54:10.630853 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.633164 (Thread-3): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_int":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_boolean_to_int', 'new_type': 'integer'}]
  
2021-12-02 20:54:10.634930 (Thread-1): Database Error in model change_column_names (models/change_column_names.sql)
  syntax error at or near "new"
  LINE 3: ...ests"."test_dbt"."change_column_names" add column new column...
                                                               ^
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.SyntaxError: syntax error at or near "new"
LINE 3: ...ests"."test_dbt"."change_column_names" add column new column...
                                                             ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 39, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 53, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 33, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model change_column_names (models/change_column_names.sql)
  syntax error at or near "new"
  LINE 3: ...ests"."test_dbt"."change_column_names" add column new column...
                                                               ^
2021-12-02 20:54:10.627290 (Thread-9): 
    In "integrationtests"."test_dbt"."convert_column_int_to_float":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_int_to_float', 'new_type': 'numeric(2,1)'}]
  
2021-12-02 20:54:10.641880 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:54:10.643933 (Thread-1): 20:54:10 | 1 of 13 ERROR creating incremental model test_dbt.change_column_names........................................ [ERROR in 50.31s]
2021-12-02 20:54:10.646574 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:54:10.647715 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.649172 (Thread-1): Finished running node model.incremental_test_schema_change.change_column_names
2021-12-02 20:54:10.650762 (Thread-10): SQL status: ALTER TABLE in 0.39 seconds
2021-12-02 20:54:10.651359 (Thread-8): SQL status: ALTER TABLE in 0.40 seconds
2021-12-02 20:54:10.651600 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.656580 (Thread-10): 
    In "integrationtests"."test_dbt"."convert_column_int_to_string":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_int_to_string', 'new_type': 'character varying(1)'}]
  
2021-12-02 20:54:10.658319 (Thread-8): 
    In "integrationtests"."test_dbt"."convert_column_int_to_boolean":
        Schema change approach: sync_all_columns
        Columns added: []
        Columns removed: []
        Data types changed: [{'column_name': 'column_int_to_boolean', 'new_type': 'boolean'}]
  
2021-12-02 20:54:10.664703 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:54:10.664984 (Thread-4): Postgres error: column "column_boolean_to_string__dbt_alter" is of type character varying but expression is of type boolean
HINT:  You will need to rewrite or cast the expression.

2021-12-02 20:54:10.667343 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:54:10.668652 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.669809 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: ROLLBACK
2021-12-02 20:54:10.671064 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:54:10.676416 (Thread-13): finished collecting timing info
2021-12-02 20:54:10.677599 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_int: Close
2021-12-02 20:54:10.679017 (Thread-13): Database Error in model convert_column_string_to_int (models/change_column_types/convert_column_string_to_int.sql)
  column "column_string_to_int__dbt_alter" is of type integer but expression is of type character varying
  HINT:  You will need to rewrite or cast the expression.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.DatatypeMismatch: column "column_string_to_int__dbt_alter" is of type integer but expression is of type character varying
HINT:  You will need to rewrite or cast the expression.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 63, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 55, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model convert_column_string_to_int (models/change_column_types/convert_column_string_to_int.sql)
  column "column_string_to_int__dbt_alter" is of type integer but expression is of type character varying
  HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:10.680926 (Thread-5): finished collecting timing info
2021-12-02 20:54:10.681404 (Thread-13): 20:54:10 | 13 of 13 ERROR creating incremental model test_dbt.convert_column_string_to_int.............................. [ERROR in 50.33s]
2021-12-02 20:54:10.682815 (Thread-5): On model.incremental_test_schema_change.convert_column_float_to_boolean: Close
2021-12-02 20:54:10.684036 (Thread-13): Finished running node model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:54:10.685883 (Thread-5): Database Error in model convert_column_float_to_boolean (models/change_column_types/convert_column_float_to_boolean.sql)
  column "column_float_to_boolean__dbt_alter" is of type boolean but expression is of type numeric
  HINT:  You will need to rewrite or cast the expression.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.DatatypeMismatch: column "column_float_to_boolean__dbt_alter" is of type boolean but expression is of type numeric
HINT:  You will need to rewrite or cast the expression.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 63, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 55, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model convert_column_float_to_boolean (models/change_column_types/convert_column_float_to_boolean.sql)
  column "column_float_to_boolean__dbt_alter" is of type boolean but expression is of type numeric
  HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:10.689286 (Thread-5): 20:54:10 | 5 of 13 ERROR creating incremental model test_dbt.convert_column_float_to_boolean............................ [ERROR in 50.35s]
2021-12-02 20:54:10.690779 (Thread-5): Finished running node model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:54:10.713399 (Thread-2): finished collecting timing info
2021-12-02 20:54:10.714763 (Thread-2): On model.incremental_test_schema_change.convert_column_boolean_to_float: Close
2021-12-02 20:54:10.716398 (Thread-2): Database Error in model convert_column_boolean_to_float (models/change_column_types/convert_column_boolean_to_float.sql)
  column "column_boolean_to_float__dbt_alter" is of type numeric but expression is of type boolean
  HINT:  You will need to rewrite or cast the expression.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.DatatypeMismatch: column "column_boolean_to_float__dbt_alter" is of type numeric but expression is of type boolean
HINT:  You will need to rewrite or cast the expression.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 63, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 55, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model convert_column_boolean_to_float (models/change_column_types/convert_column_boolean_to_float.sql)
  column "column_boolean_to_float__dbt_alter" is of type numeric but expression is of type boolean
  HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:10.719395 (Thread-2): 20:54:10 | 2 of 13 ERROR creating incremental model test_dbt.convert_column_boolean_to_float............................ [ERROR in 50.39s]
2021-12-02 20:54:10.720973 (Thread-2): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:54:10.794846 (Thread-4): finished collecting timing info
2021-12-02 20:54:10.798041 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_string: Close
2021-12-02 20:54:10.800933 (Thread-4): Database Error in model convert_column_boolean_to_string (models/change_column_types/convert_column_boolean_to_string.sql)
  column "column_boolean_to_string__dbt_alter" is of type character varying but expression is of type boolean
  HINT:  You will need to rewrite or cast the expression.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.DatatypeMismatch: column "column_boolean_to_string__dbt_alter" is of type character varying but expression is of type boolean
HINT:  You will need to rewrite or cast the expression.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 148, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 66, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 63, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 24, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 55, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model convert_column_boolean_to_string (models/change_column_types/convert_column_boolean_to_string.sql)
  column "column_boolean_to_string__dbt_alter" is of type character varying but expression is of type boolean
  HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:10.804235 (Thread-4): 20:54:10 | 4 of 13 ERROR creating incremental model test_dbt.convert_column_boolean_to_string........................... [ERROR in 50.47s]
2021-12-02 20:54:10.805960 (Thread-4): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:54:17.124403 (Thread-7): SQL status: SELECT in 6.64 seconds
2021-12-02 20:54:17.129378 (Thread-7): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_float_to_string"
2021-12-02 20:54:17.134175 (Thread-6): SQL status: SELECT in 6.49 seconds
2021-12-02 20:54:17.137733 (Thread-6): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_float_to_int"
2021-12-02 20:54:17.138020 (Thread-12): SQL status: SELECT in 6.51 seconds
2021-12-02 20:54:17.142717 (Thread-12): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_string_to_float"
2021-12-02 20:54:17.149910 (Thread-10): SQL status: SELECT in 6.48 seconds
2021-12-02 20:54:17.153670 (Thread-10): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_string"
2021-12-02 20:54:17.153886 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:54:17.156128 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:54:17.157423 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:54:17.161888 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_float_to_int" ("insert_time", "column_float_to_int")
    (
       select "insert_time", "column_float_to_int"
       from "convert_column_float_to_int__dbt_tmp205320479364"
    );
  
2021-12-02 20:54:17.158154 (Thread-8): SQL status: SELECT in 6.48 seconds
2021-12-02 20:54:17.160068 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_string_to_float" ("insert_time", "column_string_to_float")
    (
       select "insert_time", "column_string_to_float"
       from "convert_column_string_to_float__dbt_tmp205320578419"
    );
  
2021-12-02 20:54:17.160441 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:54:17.170408 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_string" ("insert_time", "column_int_to_string")
    (
       select "insert_time", "column_int_to_string"
       from "convert_column_int_to_string__dbt_tmp205320566301"
    );
  
2021-12-02 20:54:17.167043 (Thread-8): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_boolean"
2021-12-02 20:54:17.167921 (Thread-9): SQL status: SELECT in 6.51 seconds
2021-12-02 20:54:17.176188 (Thread-9): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_float"
2021-12-02 20:54:17.157669 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_float_to_string" ("insert_time", "column_float_to_string")
    (
       select "insert_time", "column_float_to_string"
       from "convert_column_float_to_string__dbt_tmp205320555306"
    );
  
2021-12-02 20:54:17.176473 (Thread-3): SQL status: SELECT in 6.52 seconds
2021-12-02 20:54:17.177621 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:54:17.181255 (Thread-3): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_int"
2021-12-02 20:54:17.182565 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:54:17.182775 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_boolean" ("insert_time", "column_int_to_boolean")
    (
       select "insert_time", "column_int_to_boolean"
       from "convert_column_int_to_boolean__dbt_tmp205320559610"
    );
  
2021-12-02 20:54:17.185041 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_float" ("insert_time", "column_int_to_float")
    (
       select "insert_time", "column_int_to_float"
       from "convert_column_int_to_float__dbt_tmp205320571814"
    );
  
2021-12-02 20:54:17.187378 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:54:17.190006 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_boolean_to_int" ("insert_time", "column_boolean_to_int")
    (
       select "insert_time", "column_boolean_to_int"
       from "convert_column_boolean_to_int__dbt_tmp205320537164"
    );
  
2021-12-02 20:54:17.325050 (Thread-6): SQL status: INSERT 0 1 in 0.16 seconds
2021-12-02 20:54:17.340967 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: COMMIT
2021-12-02 20:54:17.342704 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:54:17.344426 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: COMMIT
2021-12-02 20:54:17.423349 (Thread-8): SQL status: INSERT 0 1 in 0.24 seconds
2021-12-02 20:54:17.428460 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: COMMIT
2021-12-02 20:54:17.430728 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:54:17.432482 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: COMMIT
2021-12-02 20:54:17.433648 (Thread-12): SQL status: INSERT 0 1 in 0.26 seconds
2021-12-02 20:54:17.437327 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: COMMIT
2021-12-02 20:54:17.438878 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:54:17.440297 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: COMMIT
2021-12-02 20:54:17.444069 (Thread-10): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:54:17.447113 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: COMMIT
2021-12-02 20:54:17.448849 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:54:17.450502 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: COMMIT
2021-12-02 20:54:17.457327 (Thread-9): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:54:17.458104 (Thread-7): SQL status: INSERT 0 1 in 0.28 seconds
2021-12-02 20:54:17.458851 (Thread-3): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:54:17.460639 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: COMMIT
2021-12-02 20:54:17.463577 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: COMMIT
2021-12-02 20:54:17.466789 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: COMMIT
2021-12-02 20:54:17.468283 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:54:17.470095 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:54:17.471675 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:54:17.473148 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: COMMIT
2021-12-02 20:54:17.474956 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: COMMIT
2021-12-02 20:54:17.476865 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: COMMIT
2021-12-02 20:54:17.975438 (Thread-10): SQL status: COMMIT in 0.52 seconds
2021-12-02 20:54:17.976667 (Thread-8): SQL status: COMMIT in 0.54 seconds
2021-12-02 20:54:17.977365 (Thread-12): SQL status: COMMIT in 0.54 seconds
2021-12-02 20:54:17.984724 (Thread-12): finished collecting timing info
2021-12-02 20:54:17.978253 (Thread-3): SQL status: COMMIT in 0.50 seconds
2021-12-02 20:54:17.978677 (Thread-9): SQL status: COMMIT in 0.50 seconds
2021-12-02 20:54:17.978952 (Thread-7): SQL status: COMMIT in 0.50 seconds
2021-12-02 20:54:17.980078 (Thread-10): finished collecting timing info
2021-12-02 20:54:17.982311 (Thread-8): finished collecting timing info
2021-12-02 20:54:17.977845 (Thread-6): SQL status: COMMIT in 0.63 seconds
2021-12-02 20:54:17.986469 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_float: Close
2021-12-02 20:54:17.988430 (Thread-3): finished collecting timing info
2021-12-02 20:54:17.990394 (Thread-9): finished collecting timing info
2021-12-02 20:54:17.993101 (Thread-7): finished collecting timing info
2021-12-02 20:54:17.995278 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_string: Close
2021-12-02 20:54:17.998939 (Thread-8): On model.incremental_test_schema_change.convert_column_int_to_boolean: Close
2021-12-02 20:54:18.002087 (Thread-6): finished collecting timing info
2021-12-02 20:54:18.004849 (Thread-12): 20:54:18 | 12 of 13 OK created incremental model test_dbt.convert_column_string_to_float................................ [INSERT 0 1 in 57.65s]
2021-12-02 20:54:18.006328 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_int: Close
2021-12-02 20:54:18.007916 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_float: Close
2021-12-02 20:54:18.009410 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_string: Close
2021-12-02 20:54:18.011838 (Thread-10): 20:54:18 | 10 of 13 OK created incremental model test_dbt.convert_column_int_to_string.................................. [INSERT 0 1 in 57.66s]
2021-12-02 20:54:18.014142 (Thread-8): 20:54:18 | 8 of 13 OK created incremental model test_dbt.convert_column_int_to_boolean.................................. [INSERT 0 1 in 57.67s]
2021-12-02 20:54:18.015393 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_int: Close
2021-12-02 20:54:18.017436 (Thread-12): Finished running node model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:54:18.019502 (Thread-3): 20:54:18 | 3 of 13 OK created incremental model test_dbt.convert_column_boolean_to_int.................................. [INSERT 0 1 in 57.69s]
2021-12-02 20:54:18.021399 (Thread-9): 20:54:18 | 9 of 13 OK created incremental model test_dbt.convert_column_int_to_float.................................... [INSERT 0 1 in 57.68s]
2021-12-02 20:54:18.023278 (Thread-7): 20:54:18 | 7 of 13 OK created incremental model test_dbt.convert_column_float_to_string................................. [INSERT 0 1 in 57.68s]
2021-12-02 20:54:18.024631 (Thread-10): Finished running node model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:54:18.026361 (Thread-8): Finished running node model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:54:18.028929 (Thread-6): 20:54:18 | 6 of 13 OK created incremental model test_dbt.convert_column_float_to_int.................................... [INSERT 0 1 in 57.71s]
2021-12-02 20:54:18.031716 (Thread-3): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:54:18.033658 (Thread-9): Finished running node model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:54:18.035777 (Thread-7): Finished running node model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:54:18.040588 (Thread-6): Finished running node model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:54:18.051918 (MainThread): Acquiring new redshift connection "master".
2021-12-02 20:54:18.053363 (MainThread): Using redshift connection "master".
2021-12-02 20:54:18.054647 (MainThread): On master: BEGIN
2021-12-02 20:54:18.055914 (MainThread): Opening a new connection, currently in state closed
2021-12-02 20:54:18.057063 (MainThread): Connecting to Redshift using 'database' credentials
2021-12-02 20:54:19.072493 (MainThread): SQL status: BEGIN in 1.02 seconds
2021-12-02 20:54:19.076074 (MainThread): On master: COMMIT
2021-12-02 20:54:19.078091 (MainThread): Using redshift connection "master".
2021-12-02 20:54:19.080794 (MainThread): On master: COMMIT
2021-12-02 20:54:19.191204 (MainThread): SQL status: COMMIT in 0.11 seconds
2021-12-02 20:54:19.194942 (MainThread): On master: Close
2021-12-02 20:54:19.197989 (MainThread): 20:54:19 | 
2021-12-02 20:54:19.199766 (MainThread): 20:54:19 | Finished running 13 incremental models in 64.40s.
2021-12-02 20:54:19.201709 (MainThread): Connection 'master' was properly closed.
2021-12-02 20:54:19.203688 (MainThread): Connection 'model.incremental_test_schema_change.change_column_names' was properly closed.
2021-12-02 20:54:19.205449 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_int' was properly closed.
2021-12-02 20:54:19.207205 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_float' was properly closed.
2021-12-02 20:54:19.208781 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_int' was properly closed.
2021-12-02 20:54:19.210584 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_string' was properly closed.
2021-12-02 20:54:19.212618 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_boolean' was properly closed.
2021-12-02 20:54:19.214657 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_string' was properly closed.
2021-12-02 20:54:19.216126 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_boolean' was properly closed.
2021-12-02 20:54:19.217657 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_float' was properly closed.
2021-12-02 20:54:19.219265 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_string' was properly closed.
2021-12-02 20:54:19.221020 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_float' was properly closed.
2021-12-02 20:54:19.222753 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_int' was properly closed.
2021-12-02 20:54:19.224399 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_boolean' was properly closed.
2021-12-02 20:54:19.241267 (MainThread): 
2021-12-02 20:54:19.243204 (MainThread): Completed with 6 errors and 0 warnings:
2021-12-02 20:54:19.245091 (MainThread): 
2021-12-02 20:54:19.247323 (MainThread): Database Error in model convert_column_string_to_boolean (models/change_column_types/convert_column_string_to_boolean.sql)
2021-12-02 20:54:19.249580 (MainThread):   column "column_string_to_boolean__dbt_alter" is of type boolean but expression is of type character varying
2021-12-02 20:54:19.251854 (MainThread):   HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:19.253697 (MainThread): 
2021-12-02 20:54:19.255913 (MainThread): Database Error in model change_column_names (models/change_column_names.sql)
2021-12-02 20:54:19.257907 (MainThread):   syntax error at or near "new"
2021-12-02 20:54:19.259691 (MainThread):   LINE 3: ...ests"."test_dbt"."change_column_names" add column new column...
2021-12-02 20:54:19.261355 (MainThread):                                                                ^
2021-12-02 20:54:19.262818 (MainThread): 
2021-12-02 20:54:19.264235 (MainThread): Database Error in model convert_column_string_to_int (models/change_column_types/convert_column_string_to_int.sql)
2021-12-02 20:54:19.265702 (MainThread):   column "column_string_to_int__dbt_alter" is of type integer but expression is of type character varying
2021-12-02 20:54:19.266809 (MainThread):   HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:19.268030 (MainThread): 
2021-12-02 20:54:19.269270 (MainThread): Database Error in model convert_column_float_to_boolean (models/change_column_types/convert_column_float_to_boolean.sql)
2021-12-02 20:54:19.270605 (MainThread):   column "column_float_to_boolean__dbt_alter" is of type boolean but expression is of type numeric
2021-12-02 20:54:19.272584 (MainThread):   HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:19.274211 (MainThread): 
2021-12-02 20:54:19.275964 (MainThread): Database Error in model convert_column_boolean_to_float (models/change_column_types/convert_column_boolean_to_float.sql)
2021-12-02 20:54:19.278039 (MainThread):   column "column_boolean_to_float__dbt_alter" is of type numeric but expression is of type boolean
2021-12-02 20:54:19.280610 (MainThread):   HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:19.282838 (MainThread): 
2021-12-02 20:54:19.285951 (MainThread): Database Error in model convert_column_boolean_to_string (models/change_column_types/convert_column_boolean_to_string.sql)
2021-12-02 20:54:19.288059 (MainThread):   column "column_boolean_to_string__dbt_alter" is of type character varying but expression is of type boolean
2021-12-02 20:54:19.289935 (MainThread):   HINT:  You will need to rewrite or cast the expression.
2021-12-02 20:54:19.292122 (MainThread): 
Done. PASS=7 WARN=0 ERROR=6 SKIP=0 TOTAL=13
2021-12-02 20:54:19.294006 (MainThread): Flushing usage events
