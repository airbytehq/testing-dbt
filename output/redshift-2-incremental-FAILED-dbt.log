2021-12-02 20:51:54.764525 (MainThread): Running with dbt=0.21.0
2021-12-02 20:51:55.073805 (MainThread): running dbt with arguments Namespace(cls=<class 'dbt.task.run.RunTask'>, debug=False, defer=None, exclude=None, fail_fast=False, full_refresh=False, log_cache_events=False, log_format='default', partial_parse=None, profile=None, profiles_dir='/data/db_redshift', project_dir='/data/first_project', record_timing_info=None, rpc_method='run', select=None, selector_name=None, single_threaded=False, state=None, strict=False, target=None, test_new_parser=False, threads=None, use_cache=True, use_colors=None, use_experimental_parser=False, vars='{}', version_check=True, warn_error=False, which='run', write_json=True)
2021-12-02 20:51:55.082675 (MainThread): Tracking: do not track
2021-12-02 20:51:55.105708 (MainThread): Unable to do partial parsing because target/partial_parse.msgpack not found
2021-12-02 20:51:55.181762 (MainThread): Parsing ../macros/boolean_values.sql
2021-12-02 20:51:55.186940 (MainThread): Parsing ../macros/normalize_identifier.sql
2021-12-02 20:51:55.190947 (MainThread): Parsing macros/catalog.sql
2021-12-02 20:51:55.214093 (MainThread): Parsing macros/relations.sql
2021-12-02 20:51:55.216964 (MainThread): Parsing macros/adapters.sql
2021-12-02 20:51:55.266870 (MainThread): Parsing macros/materializations/snapshot_merge.sql
2021-12-02 20:51:55.269646 (MainThread): Parsing macros/catalog.sql
2021-12-02 20:51:55.274362 (MainThread): Parsing macros/relations.sql
2021-12-02 20:51:55.277979 (MainThread): Parsing macros/adapters.sql
2021-12-02 20:51:55.313257 (MainThread): Parsing macros/materializations/snapshot_merge.sql
2021-12-02 20:51:55.317587 (MainThread): Parsing macros/core.sql
2021-12-02 20:51:55.323923 (MainThread): Parsing macros/etc/datetime.sql
2021-12-02 20:51:55.338426 (MainThread): Parsing macros/etc/is_incremental.sql
2021-12-02 20:51:55.342367 (MainThread): Parsing macros/etc/get_custom_schema.sql
2021-12-02 20:51:55.347023 (MainThread): Parsing macros/etc/query.sql
2021-12-02 20:51:55.349216 (MainThread): Parsing macros/etc/where_subquery.sql
2021-12-02 20:51:55.352641 (MainThread): Parsing macros/etc/get_custom_alias.sql
2021-12-02 20:51:55.355646 (MainThread): Parsing macros/etc/get_custom_database.sql
2021-12-02 20:51:55.358804 (MainThread): Parsing macros/schema_tests/relationships.sql
2021-12-02 20:51:55.362105 (MainThread): Parsing macros/schema_tests/not_null.sql
2021-12-02 20:51:55.364621 (MainThread): Parsing macros/schema_tests/accepted_values.sql
2021-12-02 20:51:55.368789 (MainThread): Parsing macros/schema_tests/unique.sql
2021-12-02 20:51:55.371848 (MainThread): Parsing macros/materializations/helpers.sql
2021-12-02 20:51:55.387689 (MainThread): Parsing macros/materializations/test.sql
2021-12-02 20:51:55.399547 (MainThread): Parsing macros/materializations/seed/seed.sql
2021-12-02 20:51:55.437026 (MainThread): Parsing macros/materializations/snapshot/snapshot.sql
2021-12-02 20:51:55.490200 (MainThread): Parsing macros/materializations/snapshot/strategies.sql
2021-12-02 20:51:55.516943 (MainThread): Parsing macros/materializations/snapshot/snapshot_merge.sql
2021-12-02 20:51:55.521293 (MainThread): Parsing macros/materializations/common/merge.sql
2021-12-02 20:51:55.545059 (MainThread): Parsing macros/materializations/table/table.sql
2021-12-02 20:51:55.557185 (MainThread): Parsing macros/materializations/view/create_or_replace_view.sql
2021-12-02 20:51:55.563912 (MainThread): Parsing macros/materializations/view/view.sql
2021-12-02 20:51:55.575903 (MainThread): Parsing macros/materializations/incremental/on_schema_change.sql
2021-12-02 20:51:55.614254 (MainThread): Parsing macros/materializations/incremental/helpers.sql
2021-12-02 20:51:55.618476 (MainThread): Parsing macros/materializations/incremental/incremental.sql
2021-12-02 20:51:55.636596 (MainThread): Parsing macros/adapters/common.sql
2021-12-02 20:51:55.973901 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:51:55.991991 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:51:56.000957 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:51:56.009006 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:51:56.016620 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:51:56.022816 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:51:56.028351 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:51:56.033980 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:51:56.039485 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:51:56.046213 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:51:56.051572 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:51:56.056779 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:51:56.061951 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:51:56.067262 (MainThread): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:51:56.126520 (MainThread): write_gpickle is deprecated and will be removed in 3.0.Use ``pickle.dump(G, path, protocol)``
2021-12-02 20:51:56.128662 (MainThread): Found 14 models, 0 tests, 0 snapshots, 0 analyses, 197 macros, 0 operations, 0 seed files, 0 sources, 0 exposures
2021-12-02 20:51:56.132507 (MainThread): 
2021-12-02 20:51:56.134158 (MainThread): Acquiring new redshift connection "master".
2021-12-02 20:51:56.137240 (ThreadPoolExecutor-0_0): Acquiring new redshift connection "list_integrationtests".
2021-12-02 20:51:56.149975 (ThreadPoolExecutor-0_0): Using redshift connection "list_integrationtests".
2021-12-02 20:51:56.151449 (ThreadPoolExecutor-0_0): On list_integrationtests: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "list_integrationtests"} */

    select distinct nspname from pg_namespace
  
2021-12-02 20:51:56.153142 (ThreadPoolExecutor-0_0): Opening a new connection, currently in state init
2021-12-02 20:51:56.154162 (ThreadPoolExecutor-0_0): Connecting to Redshift using 'database' credentials
2021-12-02 20:51:57.298817 (ThreadPoolExecutor-0_0): SQL status: SELECT in 1.15 seconds
2021-12-02 20:51:57.307656 (ThreadPoolExecutor-0_0): On list_integrationtests: Close
2021-12-02 20:51:57.312346 (ThreadPoolExecutor-1_0): Acquiring new redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:51:57.323920 (ThreadPoolExecutor-1_0): Using redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:51:57.325938 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: BEGIN
2021-12-02 20:51:57.327617 (ThreadPoolExecutor-1_0): Opening a new connection, currently in state closed
2021-12-02 20:51:57.329149 (ThreadPoolExecutor-1_0): Connecting to Redshift using 'database' credentials
2021-12-02 20:51:58.285321 (ThreadPoolExecutor-1_0): SQL status: BEGIN in 0.96 seconds
2021-12-02 20:51:58.288480 (ThreadPoolExecutor-1_0): Using redshift connection "list_integrationtests_test_dbt".
2021-12-02 20:51:58.290477 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "list_integrationtests_test_dbt"} */
select
      'integrationtests' as database,
      tablename as name,
      schemaname as schema,
      'table' as type
    from pg_tables
    where schemaname ilike 'test_dbt'
    union all
    select
      'integrationtests' as database,
      viewname as name,
      schemaname as schema,
      'view' as type
    from pg_views
    where schemaname ilike 'test_dbt'
  
2021-12-02 20:51:58.445634 (ThreadPoolExecutor-1_0): SQL status: SELECT in 0.15 seconds
2021-12-02 20:51:58.451566 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: ROLLBACK
2021-12-02 20:51:58.557078 (ThreadPoolExecutor-1_0): On list_integrationtests_test_dbt: Close
2021-12-02 20:51:58.570099 (MainThread): Using redshift connection "master".
2021-12-02 20:51:58.572572 (MainThread): On master: BEGIN
2021-12-02 20:51:58.574934 (MainThread): Opening a new connection, currently in state init
2021-12-02 20:51:58.577070 (MainThread): Connecting to Redshift using 'database' credentials
2021-12-02 20:51:59.612254 (MainThread): SQL status: BEGIN in 1.04 seconds
2021-12-02 20:51:59.614084 (MainThread): Using redshift connection "master".
2021-12-02 20:51:59.615501 (MainThread): On master: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "connection_name": "master"} */
with relation as (
        select
            pg_rewrite.ev_class as class,
            pg_rewrite.oid as id
        from pg_rewrite
    ),
    class as (
        select
            oid as id,
            relname as name,
            relnamespace as schema,
            relkind as kind
        from pg_class
    ),
    dependency as (
        select
            pg_depend.objid as id,
            pg_depend.refobjid as ref
        from pg_depend
    ),
    schema as (
        select
            pg_namespace.oid as id,
            pg_namespace.nspname as name
        from pg_namespace
        where nspname != 'information_schema' and nspname not like 'pg\_%'
    ),
    referenced as (
        select
            relation.id AS id,
            referenced_class.name ,
            referenced_class.schema ,
            referenced_class.kind
        from relation
        join class as referenced_class on relation.class=referenced_class.id
        where referenced_class.kind in ('r', 'v')
    ),
    relationships as (
        select
            referenced.name as referenced_name,
            referenced.schema as referenced_schema_id,
            dependent_class.name as dependent_name,
            dependent_class.schema as dependent_schema_id,
            referenced.kind as kind
        from referenced
        join dependency on referenced.id=dependency.id
        join class as dependent_class on dependency.ref=dependent_class.id
        where
            (referenced.name != dependent_class.name or
             referenced.schema != dependent_class.schema)
    )

    select
        referenced_schema.name as referenced_schema,
        relationships.referenced_name as referenced_name,
        dependent_schema.name as dependent_schema,
        relationships.dependent_name as dependent_name
    from relationships
    join schema as dependent_schema on relationships.dependent_schema_id=dependent_schema.id
    join schema as referenced_schema on relationships.referenced_schema_id=referenced_schema.id
    group by referenced_schema, referenced_name, dependent_schema, dependent_name
    order by referenced_schema, referenced_name, dependent_schema, dependent_name;
2021-12-02 20:52:00.858623 (MainThread): SQL status: SELECT in 1.24 seconds
2021-12-02 20:52:00.885212 (MainThread): On master: ROLLBACK
2021-12-02 20:52:01.000492 (MainThread): Using redshift connection "master".
2021-12-02 20:52:01.003458 (MainThread): On master: BEGIN
2021-12-02 20:52:01.221795 (MainThread): SQL status: BEGIN in 0.22 seconds
2021-12-02 20:52:01.225389 (MainThread): On master: COMMIT
2021-12-02 20:52:01.227974 (MainThread): Using redshift connection "master".
2021-12-02 20:52:01.229962 (MainThread): On master: COMMIT
2021-12-02 20:52:01.332813 (MainThread): SQL status: COMMIT in 0.10 seconds
2021-12-02 20:52:01.336560 (MainThread): On master: Close
2021-12-02 20:52:01.340561 (MainThread): 20:52:01 | Concurrency: 32 threads (target='prod')
2021-12-02 20:52:01.342719 (MainThread): 20:52:01 | 
2021-12-02 20:52:01.366313 (Thread-1): Began running node model.incremental_test_schema_change.change_column_names
2021-12-02 20:52:01.369830 (Thread-1): 20:52:01 | 1 of 14 START incremental model test_dbt.change_column_names................................................. [RUN]
2021-12-02 20:52:01.367146 (Thread-3): Began running node model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:52:01.367553 (Thread-4): Began running node model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:52:01.367957 (Thread-5): Began running node model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:52:01.368682 (Thread-6): Began running node model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:52:01.369063 (Thread-7): Began running node model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:52:01.369408 (Thread-8): Began running node model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:52:01.366643 (Thread-2): Began running node model.incremental_test_schema_change.column_with_quotes
2021-12-02 20:52:01.370185 (Thread-9): Began running node model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:52:01.370670 (Thread-10): Began running node model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:52:01.371059 (Thread-11): Began running node model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:52:01.371366 (Thread-12): Began running node model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:52:01.371786 (Thread-13): Began running node model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:52:01.395559 (Thread-13): 20:52:01 | 13 of 14 START incremental model test_dbt.convert_column_string_to_float..................................... [RUN]
2021-12-02 20:52:01.397552 (Thread-13): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:01.374462 (Thread-3): 20:52:01 | 3 of 14 START incremental model test_dbt.convert_column_boolean_to_float..................................... [RUN]
2021-12-02 20:52:01.376690 (Thread-4): 20:52:01 | 4 of 14 START incremental model test_dbt.convert_column_boolean_to_int....................................... [RUN]
2021-12-02 20:52:01.378490 (Thread-5): 20:52:01 | 5 of 14 START incremental model test_dbt.convert_column_boolean_to_string.................................... [RUN]
2021-12-02 20:52:01.380167 (Thread-6): 20:52:01 | 6 of 14 START incremental model test_dbt.convert_column_float_to_boolean..................................... [RUN]
2021-12-02 20:52:01.382561 (Thread-7): 20:52:01 | 7 of 14 START incremental model test_dbt.convert_column_float_to_int......................................... [RUN]
2021-12-02 20:52:01.384418 (Thread-8): 20:52:01 | 8 of 14 START incremental model test_dbt.convert_column_float_to_string...................................... [RUN]
2021-12-02 20:52:01.386387 (Thread-2): 20:52:01 | 2 of 14 START incremental model test_dbt.column_with_quotes.................................................. [RUN]
2021-12-02 20:52:01.388125 (Thread-9): 20:52:01 | 9 of 14 START incremental model test_dbt.convert_column_int_to_boolean....................................... [RUN]
2021-12-02 20:52:01.390270 (Thread-10): 20:52:01 | 10 of 14 START incremental model test_dbt.convert_column_int_to_float........................................ [RUN]
2021-12-02 20:52:01.391947 (Thread-11): 20:52:01 | 11 of 14 START incremental model test_dbt.convert_column_int_to_string....................................... [RUN]
2021-12-02 20:52:01.393868 (Thread-12): 20:52:01 | 12 of 14 START incremental model test_dbt.convert_column_string_to_boolean................................... [RUN]
2021-12-02 20:52:01.372199 (Thread-14): Began running node model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:52:01.372768 (Thread-1): Acquiring new redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:01.399322 (Thread-13): Compiling model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:52:01.401770 (Thread-3): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:01.404374 (Thread-4): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:01.407288 (Thread-5): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:01.408344 (Thread-6): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:01.410231 (Thread-7): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:01.411481 (Thread-8): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:01.413442 (Thread-2): Acquiring new redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:01.414790 (Thread-9): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:01.416557 (Thread-10): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:01.417767 (Thread-11): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:01.419611 (Thread-12): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:01.420955 (Thread-14): 20:52:01 | 14 of 14 START incremental model test_dbt.convert_column_string_to_int....................................... [RUN]
2021-12-02 20:52:01.422107 (Thread-1): Compiling model.incremental_test_schema_change.change_column_names
2021-12-02 20:52:01.426301 (Thread-13): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_float"
2021-12-02 20:52:01.427804 (Thread-3): Compiling model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:52:01.429145 (Thread-4): Compiling model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:52:01.430282 (Thread-5): Compiling model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:52:01.431521 (Thread-6): Compiling model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:52:01.432635 (Thread-7): Compiling model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:52:01.433736 (Thread-8): Compiling model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:52:01.435093 (Thread-2): Compiling model.incremental_test_schema_change.column_with_quotes
2021-12-02 20:52:01.436162 (Thread-9): Compiling model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:52:01.437307 (Thread-10): Compiling model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:52:01.481358 (Thread-10): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_float"
2021-12-02 20:52:01.439669 (Thread-12): Compiling model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:52:01.441256 (Thread-14): Acquiring new redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:01.444426 (Thread-1): Writing injected SQL for node "model.incremental_test_schema_change.change_column_names"
2021-12-02 20:52:01.449377 (Thread-3): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_float"
2021-12-02 20:52:01.453342 (Thread-4): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_int"
2021-12-02 20:52:01.457616 (Thread-5): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_string"
2021-12-02 20:52:01.461838 (Thread-6): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_boolean"
2021-12-02 20:52:01.465465 (Thread-7): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_int"
2021-12-02 20:52:01.469066 (Thread-8): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_float_to_string"
2021-12-02 20:52:01.473720 (Thread-2): Writing injected SQL for node "model.incremental_test_schema_change.column_with_quotes"
2021-12-02 20:52:01.474745 (Thread-13): finished collecting timing info
2021-12-02 20:52:01.477787 (Thread-9): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_boolean"
2021-12-02 20:52:01.438432 (Thread-11): Compiling model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:52:01.486276 (Thread-12): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_boolean"
2021-12-02 20:52:01.487320 (Thread-10): finished collecting timing info
2021-12-02 20:52:01.487604 (Thread-14): Compiling model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:52:01.492333 (Thread-1): finished collecting timing info
2021-12-02 20:52:01.495331 (Thread-3): finished collecting timing info
2021-12-02 20:52:01.498512 (Thread-4): finished collecting timing info
2021-12-02 20:52:01.511932 (Thread-5): finished collecting timing info
2021-12-02 20:52:01.530767 (Thread-2): finished collecting timing info
2021-12-02 20:52:01.531191 (Thread-7): finished collecting timing info
2021-12-02 20:52:01.531584 (Thread-6): finished collecting timing info
2021-12-02 20:52:01.547130 (Thread-11): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_int_to_string"
2021-12-02 20:52:01.547359 (Thread-8): finished collecting timing info
2021-12-02 20:52:01.579725 (Thread-9): finished collecting timing info
2021-12-02 20:52:01.585724 (Thread-12): finished collecting timing info
2021-12-02 20:52:01.592137 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:01.595751 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:01.599692 (Thread-14): Writing injected SQL for node "model.incremental_test_schema_change.convert_column_string_to_int"
2021-12-02 20:52:01.604454 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:01.609186 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:01.613647 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:01.618011 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:01.622651 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:01.627174 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:01.631337 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:01.637873 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:01.642467 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:01.642894 (Thread-11): finished collecting timing info
2021-12-02 20:52:01.647040 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:01.648578 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

    

  create temporary table
    "convert_column_string_to_float__dbt_tmp205201555526"
    
    
  as (
    select
    '1.1' as column_string_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.649679 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

    

  create temporary table
    "convert_column_int_to_float__dbt_tmp205201594424"
    
    
  as (
    select
    1 as column_int_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.652133 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

    

  create temporary table
    "change_column_names__dbt_tmp205201602970"
    
    
  as (
    select
    'a column with underscore' as column_name,
    'a column to rename' as column_to_rename,
    'a column to be deleted' as column_to_delete,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.653381 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

    

  create temporary table
    "convert_column_boolean_to_float__dbt_tmp205201607803"
    
    
  as (
    select
    true as column_boolean_to_float,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.654481 (Thread-14): finished collecting timing info
2021-12-02 20:52:01.654966 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

    

  create temporary table
    "convert_column_boolean_to_int__dbt_tmp205201612365"
    
    
  as (
    select
    true as column_boolean_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.656169 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

    

  create temporary table
    "convert_column_boolean_to_string__dbt_tmp205201616622"
    
    
  as (
    select
    true as column_boolean_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.657496 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

    

  create temporary table
    "column_with_quotes__dbt_tmp205201621301"
    
    
  as (
    select
    'a column with tricky name with quotes' as  "column`_'with""_quotes",
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.658613 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

    

  create temporary table
    "convert_column_float_to_int__dbt_tmp205201625847"
    
    
  as (
    select
    1.1 as column_float_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.659922 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

    

  create temporary table
    "convert_column_float_to_boolean__dbt_tmp205201630033"
    
    
  as (
    select
    1.1 as column_float_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.661237 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

    

  create temporary table
    "convert_column_float_to_string__dbt_tmp205201636459"
    
    
  as (
    select
    1.1 as column_float_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.662414 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

    

  create temporary table
    "convert_column_int_to_boolean__dbt_tmp205201641100"
    
    
  as (
    select
    1 as column_int_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.667104 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:01.669334 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

    

  create temporary table
    "convert_column_string_to_boolean__dbt_tmp205201645719"
    
    
  as (
    select
    'true' as column_string_to_boolean,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.670819 (Thread-13): Opening a new connection, currently in state init
2021-12-02 20:52:01.672110 (Thread-10): Opening a new connection, currently in state init
2021-12-02 20:52:01.673495 (Thread-1): Opening a new connection, currently in state closed
2021-12-02 20:52:01.674691 (Thread-3): Opening a new connection, currently in state init
2021-12-02 20:52:01.679238 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:01.680613 (Thread-4): Opening a new connection, currently in state init
2021-12-02 20:52:01.681976 (Thread-5): Opening a new connection, currently in state init
2021-12-02 20:52:01.683206 (Thread-2): Opening a new connection, currently in state init
2021-12-02 20:52:01.684672 (Thread-7): Opening a new connection, currently in state init
2021-12-02 20:52:01.686615 (Thread-6): Opening a new connection, currently in state init
2021-12-02 20:52:01.688038 (Thread-8): Opening a new connection, currently in state init
2021-12-02 20:52:01.689402 (Thread-9): Opening a new connection, currently in state init
2021-12-02 20:52:01.690637 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

    

  create temporary table
    "convert_column_int_to_string__dbt_tmp205201665695"
    
    
  as (
    select
    1 as column_int_to_string,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.692337 (Thread-12): Opening a new connection, currently in state init
2021-12-02 20:52:01.693924 (Thread-13): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.695315 (Thread-10): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.696537 (Thread-1): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.697813 (Thread-3): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.699282 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

    

  create temporary table
    "convert_column_string_to_int__dbt_tmp205201677841"
    
    
  as (
    select
    '1' as column_string_to_int,
    getdate() as insert_time
  );
  
2021-12-02 20:52:01.700698 (Thread-4): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.702111 (Thread-5): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.703314 (Thread-2): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.704589 (Thread-7): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.705914 (Thread-6): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.707229 (Thread-8): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.708413 (Thread-9): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.709751 (Thread-11): Opening a new connection, currently in state init
2021-12-02 20:52:01.711043 (Thread-12): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.720445 (Thread-14): Opening a new connection, currently in state init
2021-12-02 20:52:01.734530 (Thread-11): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:01.737950 (Thread-14): Connecting to Redshift using 'database' credentials
2021-12-02 20:52:02.884825 (Thread-10): SQL status: SELECT in 1.21 seconds
2021-12-02 20:52:02.896415 (Thread-5): SQL status: SELECT in 1.21 seconds
2021-12-02 20:52:02.898361 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:02.902772 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:02.904754 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: BEGIN
2021-12-02 20:52:02.907135 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: BEGIN
2021-12-02 20:52:02.923389 (Thread-9): SQL status: SELECT in 1.23 seconds
2021-12-02 20:52:02.927977 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:02.929338 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: BEGIN
2021-12-02 20:52:02.928243 (Thread-13): SQL status: SELECT in 1.26 seconds
2021-12-02 20:52:02.934130 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:02.931656 (Thread-6): SQL status: SELECT in 1.25 seconds
2021-12-02 20:52:02.935362 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: BEGIN
2021-12-02 20:52:02.939652 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:02.942906 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: BEGIN
2021-12-02 20:52:03.016241 (Thread-10): SQL status: BEGIN in 0.11 seconds
2021-12-02 20:52:03.019576 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:03.021845 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float__dbt_tmp205201594424'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float__dbt_tmp205201594424'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_float__dbt_tmp205201594424'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.025837 (Thread-5): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:52:03.027305 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:03.028796 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string__dbt_tmp205201616622'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string__dbt_tmp205201616622'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_string__dbt_tmp205201616622'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.040388 (Thread-6): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:52:03.042440 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:03.044110 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean__dbt_tmp205201630033'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean__dbt_tmp205201630033'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_boolean__dbt_tmp205201630033'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.042240 (Thread-9): SQL status: BEGIN in 0.11 seconds
2021-12-02 20:52:03.045249 (Thread-13): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:52:03.048189 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:03.049844 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:03.051358 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean__dbt_tmp205201641100'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean__dbt_tmp205201641100'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_boolean__dbt_tmp205201641100'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.053079 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float__dbt_tmp205201555526'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float__dbt_tmp205201555526'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_float__dbt_tmp205201555526'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.059535 (Thread-14): SQL status: SELECT in 1.34 seconds
2021-12-02 20:52:03.063835 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:03.065158 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: BEGIN
2021-12-02 20:52:03.068590 (Thread-1): SQL status: SELECT in 1.40 seconds
2021-12-02 20:52:03.073308 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:03.073509 (Thread-12): SQL status: SELECT in 1.38 seconds
2021-12-02 20:52:03.073626 (Thread-4): SQL status: SELECT in 1.39 seconds
2021-12-02 20:52:03.073807 (Thread-8): SQL status: SELECT in 1.39 seconds
2021-12-02 20:52:03.074044 (Thread-3): SQL status: SELECT in 1.40 seconds
2021-12-02 20:52:03.074778 (Thread-1): On model.incremental_test_schema_change.change_column_names: BEGIN
2021-12-02 20:52:03.078674 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:03.078925 (Thread-2): SQL status: SELECT in 1.40 seconds
2021-12-02 20:52:03.085089 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:03.088888 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:03.092554 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:03.101520 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: BEGIN
2021-12-02 20:52:03.098431 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:03.099477 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: BEGIN
2021-12-02 20:52:03.100437 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: BEGIN
2021-12-02 20:52:03.095159 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: BEGIN
2021-12-02 20:52:03.104158 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: BEGIN
2021-12-02 20:52:03.183537 (Thread-14): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:52:03.186521 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:03.188540 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int__dbt_tmp205201677841'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int__dbt_tmp205201677841'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_int__dbt_tmp205201677841'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.198098 (Thread-1): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:52:03.199781 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:03.201466 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names__dbt_tmp205201602970'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names__dbt_tmp205201602970'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'change_column_names__dbt_tmp205201602970'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.206903 (Thread-2): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:52:03.208810 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:03.210322 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'column_with_quotes__dbt_tmp205201621301'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'column_with_quotes__dbt_tmp205201621301'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'column_with_quotes__dbt_tmp205201621301'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.208195 (Thread-8): SQL status: BEGIN in 0.10 seconds
2021-12-02 20:52:03.213993 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:03.215676 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string__dbt_tmp205201636459'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string__dbt_tmp205201636459'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_string__dbt_tmp205201636459'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.230379 (Thread-3): SQL status: BEGIN in 0.13 seconds
2021-12-02 20:52:03.230632 (Thread-12): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:52:03.233957 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:03.235311 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean__dbt_tmp205201645719'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean__dbt_tmp205201645719'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_boolean__dbt_tmp205201645719'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.230816 (Thread-4): SQL status: BEGIN in 0.13 seconds
2021-12-02 20:52:03.232244 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:03.239157 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:03.240650 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float__dbt_tmp205201607803'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float__dbt_tmp205201607803'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_float__dbt_tmp205201607803'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.242076 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int__dbt_tmp205201612365'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int__dbt_tmp205201612365'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_int__dbt_tmp205201612365'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:03.846445 (Thread-11): SQL status: SELECT in 2.14 seconds
2021-12-02 20:52:03.853798 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:03.855687 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: BEGIN
2021-12-02 20:52:03.972804 (Thread-11): SQL status: BEGIN in 0.12 seconds
2021-12-02 20:52:03.976397 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:03.978478 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string__dbt_tmp205201665695'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string__dbt_tmp205201665695'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_string__dbt_tmp205201665695'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:04.017401 (Thread-7): SQL status: SELECT in 2.33 seconds
2021-12-02 20:52:04.024587 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:04.026359 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: BEGIN
2021-12-02 20:52:04.154633 (Thread-7): SQL status: BEGIN in 0.13 seconds
2021-12-02 20:52:04.158292 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:04.160221 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int__dbt_tmp205201625847'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int__dbt_tmp205201625847'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_int__dbt_tmp205201625847'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:15.642457 (Thread-1): SQL status: SELECT in 12.44 seconds
2021-12-02 20:52:15.653971 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:15.656028 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'change_column_names'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.707116 (Thread-5): SQL status: SELECT in 12.68 seconds
2021-12-02 20:52:15.709561 (Thread-8): SQL status: SELECT in 12.49 seconds
2021-12-02 20:52:15.713619 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:15.718684 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:15.720536 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.725191 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.726071 (Thread-3): SQL status: SELECT in 12.48 seconds
2021-12-02 20:52:15.736382 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:15.743155 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.755759 (Thread-11): SQL status: SELECT in 11.77 seconds
2021-12-02 20:52:15.759479 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:15.759809 (Thread-14): SQL status: SELECT in 12.57 seconds
2021-12-02 20:52:15.761340 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.761663 (Thread-13): SQL status: SELECT in 12.70 seconds
2021-12-02 20:52:15.765047 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:15.771643 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:15.773366 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.773646 (Thread-10): SQL status: SELECT in 12.75 seconds
2021-12-02 20:52:15.774837 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.820037 (Thread-6): SQL status: SELECT in 12.77 seconds
2021-12-02 20:52:15.820335 (Thread-4): SQL status: SELECT in 12.58 seconds
2021-12-02 20:52:15.820521 (Thread-9): SQL status: SELECT in 12.77 seconds
2021-12-02 20:52:15.820972 (Thread-12): SQL status: SELECT in 12.58 seconds
2021-12-02 20:52:15.822659 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:15.830103 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:15.835132 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:15.840377 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:15.845400 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:15.847066 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.848632 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.850512 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.853332 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.855006 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:15.930883 (Thread-2): SQL status: SELECT in 12.72 seconds
2021-12-02 20:52:15.938191 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:15.940152 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'column_with_quotes'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'column_with_quotes'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'column_with_quotes'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:16.125964 (Thread-7): SQL status: SELECT in 11.96 seconds
2021-12-02 20:52:16.133857 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:16.136306 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:28.012545 (Thread-9): SQL status: SELECT in 12.15 seconds
2021-12-02 20:52:28.013195 (Thread-12): SQL status: SELECT in 12.15 seconds
2021-12-02 20:52:28.013808 (Thread-7): SQL status: SELECT in 11.88 seconds
2021-12-02 20:52:28.014786 (Thread-1): SQL status: SELECT in 12.36 seconds
2021-12-02 20:52:28.015396 (Thread-4): SQL status: SELECT in 12.15 seconds
2021-12-02 20:52:28.015653 (Thread-5): SQL status: SELECT in 12.29 seconds
2021-12-02 20:52:28.015868 (Thread-6): SQL status: SELECT in 12.16 seconds
2021-12-02 20:52:28.016218 (Thread-13): SQL status: SELECT in 12.19 seconds
2021-12-02 20:52:28.023411 (Thread-14): SQL status: SELECT in 12.25 seconds
2021-12-02 20:52:28.034185 (Thread-2): SQL status: SELECT in 12.09 seconds
2021-12-02 20:52:28.034532 (Thread-11): SQL status: SELECT in 12.27 seconds
2021-12-02 20:52:28.041328 (Thread-10): SQL status: SELECT in 12.18 seconds
2021-12-02 20:52:28.040619 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:28.046443 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:28.046744 (Thread-8): SQL status: SELECT in 12.32 seconds
2021-12-02 20:52:28.102484 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:28.052371 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:28.057274 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:28.063333 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:28.068432 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:28.073951 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:28.078555 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:28.082828 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:28.112322 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int__dbt_tmp205201677841'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int__dbt_tmp205201677841'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_int__dbt_tmp205201677841'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.091719 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:28.095885 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:28.097486 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean__dbt_tmp205201641100'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean__dbt_tmp205201641100'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_boolean__dbt_tmp205201641100'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.098794 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean__dbt_tmp205201645719'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean__dbt_tmp205201645719'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_boolean__dbt_tmp205201645719'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.048624 (Thread-3): SQL status: SELECT in 12.30 seconds
2021-12-02 20:52:28.103553 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string__dbt_tmp205201636459'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string__dbt_tmp205201636459'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_string__dbt_tmp205201636459'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.104700 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int__dbt_tmp205201625847'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int__dbt_tmp205201625847'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_int__dbt_tmp205201625847'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.106013 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names__dbt_tmp205201602970'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names__dbt_tmp205201602970'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'change_column_names__dbt_tmp205201602970'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.107137 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int__dbt_tmp205201612365'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int__dbt_tmp205201612365'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_int__dbt_tmp205201612365'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.108440 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string__dbt_tmp205201616622'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string__dbt_tmp205201616622'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_string__dbt_tmp205201616622'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.109567 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean__dbt_tmp205201630033'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean__dbt_tmp205201630033'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_float_to_boolean__dbt_tmp205201630033'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.111090 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float__dbt_tmp205201555526'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float__dbt_tmp205201555526'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_string_to_float__dbt_tmp205201555526'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.087136 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:28.115347 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string__dbt_tmp205201665695'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string__dbt_tmp205201665695'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_string__dbt_tmp205201665695'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.116560 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float__dbt_tmp205201594424'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float__dbt_tmp205201594424'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_int_to_float__dbt_tmp205201594424'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.123605 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:28.140945 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float__dbt_tmp205201607803'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float__dbt_tmp205201607803'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'convert_column_boolean_to_float__dbt_tmp205201607803'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:28.136005 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'column_with_quotes__dbt_tmp205201621301'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'column_with_quotes__dbt_tmp205201621301'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'None'
        and tablename = 'column_with_quotes__dbt_tmp205201621301'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    order by ordinal_position
  
2021-12-02 20:52:40.323661 (Thread-13): SQL status: SELECT in 12.19 seconds
2021-12-02 20:52:40.329552 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:40.329859 (Thread-11): SQL status: SELECT in 12.19 seconds
2021-12-02 20:52:40.331580 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.336734 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:40.340637 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.342630 (Thread-2): SQL status: SELECT in 12.20 seconds
2021-12-02 20:52:40.347565 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:40.348795 (Thread-5): SQL status: SELECT in 12.22 seconds
2021-12-02 20:52:40.349492 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'column_with_quotes'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'column_with_quotes'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'column_with_quotes'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.355925 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:40.359931 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.362592 (Thread-8): SQL status: SELECT in 12.24 seconds
2021-12-02 20:52:40.367065 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:40.368578 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.374812 (Thread-6): SQL status: SELECT in 12.24 seconds
2021-12-02 20:52:40.379013 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:40.379473 (Thread-14): SQL status: SELECT in 12.27 seconds
2021-12-02 20:52:40.379807 (Thread-9): SQL status: SELECT in 12.26 seconds
2021-12-02 20:52:40.380012 (Thread-1): SQL status: SELECT in 12.25 seconds
2021-12-02 20:52:40.380227 (Thread-3): SQL status: SELECT in 12.24 seconds
2021-12-02 20:52:40.380785 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.384417 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:40.388091 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:40.391813 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:40.396134 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:40.403150 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.400680 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.401984 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'change_column_names'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.399440 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.405349 (Thread-12): SQL status: SELECT in 12.29 seconds
2021-12-02 20:52:40.409151 (Thread-4): SQL status: SELECT in 12.28 seconds
2021-12-02 20:52:40.412849 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:40.413123 (Thread-7): SQL status: SELECT in 12.29 seconds
2021-12-02 20:52:40.416425 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:40.417451 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.420953 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:40.421986 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.424096 (Thread-10): SQL status: SELECT in 12.28 seconds
2021-12-02 20:52:40.425247 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:40.430554 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:40.433539 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.594051 (Thread-13): SQL status: SELECT in 12.25 seconds
2021-12-02 20:52:52.611984 (Thread-4): SQL status: SELECT in 12.18 seconds
2021-12-02 20:52:52.614179 (Thread-13): 
    In "integrationtests"."test_dbt"."convert_column_string_to_float":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.617478 (Thread-4): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_int":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.617857 (Thread-3): SQL status: SELECT in 12.21 seconds
2021-12-02 20:52:52.618213 (Thread-1): SQL status: SELECT in 12.21 seconds
2021-12-02 20:52:52.627116 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:52:52.630191 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:52:52.636511 (Thread-3): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_float":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.641059 (Thread-1): 
    In "integrationtests"."test_dbt"."change_column_names":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.643229 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.645129 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.645769 (Thread-8): SQL status: SELECT in 12.28 seconds
2021-12-02 20:52:52.649008 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:52:52.652955 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:52:52.658545 (Thread-14): SQL status: SELECT in 12.25 seconds
2021-12-02 20:52:52.658857 (Thread-7): SQL status: SELECT in 12.23 seconds
2021-12-02 20:52:52.661937 (Thread-8): 
    In "integrationtests"."test_dbt"."convert_column_float_to_string":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.663566 (Thread-9): SQL status: SELECT in 12.26 seconds
2021-12-02 20:52:52.664001 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.665722 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'change_column_names'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'change_column_names'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'change_column_names'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.669244 (Thread-14): 
    In "integrationtests"."test_dbt"."convert_column_string_to_int":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.673739 (Thread-7): 
    In "integrationtests"."test_dbt"."convert_column_float_to_int":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.677628 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:52:52.678251 (Thread-2): SQL status: SELECT in 12.32 seconds
2021-12-02 20:52:52.678694 (Thread-5): SQL status: SELECT in 12.32 seconds
2021-12-02 20:52:52.682657 (Thread-9): 
    In "integrationtests"."test_dbt"."convert_column_int_to_boolean":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.687782 (Thread-11): SQL status: SELECT in 12.35 seconds
2021-12-02 20:52:52.691631 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:52:52.714781 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.696054 (Thread-10): SQL status: SELECT in 12.26 seconds
2021-12-02 20:52:52.696380 (Thread-6): SQL status: SELECT in 12.30 seconds
2021-12-02 20:52:52.696624 (Thread-12): SQL status: SELECT in 12.27 seconds
2021-12-02 20:52:52.697546 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.701439 (Thread-2): 
    In "integrationtests"."test_dbt"."column_with_quotes":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.705148 (Thread-5): 
    In "integrationtests"."test_dbt"."convert_column_boolean_to_string":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.709070 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:52:52.712876 (Thread-11): 
    In "integrationtests"."test_dbt"."convert_column_int_to_string":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.695637 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:52:52.723209 (Thread-10): 
    In "integrationtests"."test_dbt"."convert_column_int_to_float":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.727198 (Thread-6): 
    In "integrationtests"."test_dbt"."convert_column_float_to_boolean":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.730664 (Thread-12): 
    In "integrationtests"."test_dbt"."convert_column_string_to_boolean":
        Schema changed: False
        Source columns not in target: []
        Target columns not in source: []
        New column types: []
  
2021-12-02 20:52:52.755248 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:52:52.739983 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:52:52.741667 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.744777 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:52:52.746437 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_int'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_int'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_int'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.749144 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:52:52.751881 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:52:52.736945 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:52:52.767272 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'column_with_quotes'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'column_with_quotes'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'column_with_quotes'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.757865 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_boolean_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_boolean_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_boolean_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.761190 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_string'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_string'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_string'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.764422 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_int_to_float'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_int_to_float'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_int_to_float'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.765850 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_float_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_float_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_float_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:52:52.756492 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      with bound_views as (
        select
          ordinal_position,
          table_schema,
          column_name,
          data_type,
          character_maximum_length,
          numeric_precision,
          numeric_scale

        from information_schema."columns"
        where table_name = 'convert_column_string_to_boolean'
    ),

    unbound_views as (
      select
        ordinal_position,
        view_schema,
        col_name,
        case
          when col_type ilike 'character varying%' then
            'character varying'
          when col_type ilike 'numeric%' then 'numeric'
          else col_type
        end as col_type,
        case
          when col_type like 'character%'
          then nullif(REGEXP_SUBSTR(col_type, '[0-9]+'), '')::int
          else null
        end as character_maximum_length,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when col_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(col_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale

      from pg_get_late_binding_view_cols()
      cols(view_schema name, view_name name, col_name name,
           col_type varchar, ordinal_position int)
      where view_name = 'convert_column_string_to_boolean'
    ),

    external_views as (
      select
        columnnum,
        schemaname,
        columnname,
        case
          when external_type ilike 'character varying%' or external_type ilike 'varchar%'
          then 'character varying'
          when external_type ilike 'numeric%' then 'numeric'
          else external_type
        end as external_type,
        case
          when external_type like 'character%' or external_type like 'varchar%'
          then nullif(
            REGEXP_SUBSTR(external_type, '[0-9]+'),
            '')::int
          else null
        end as character_maximum_length,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 1),
            '')::int
          else null
        end as numeric_precision,
        case
          when external_type like 'numeric%'
          then nullif(
            SPLIT_PART(REGEXP_SUBSTR(external_type, '[0-9,]+'), ',', 2),
            '')::int
          else null
        end as numeric_scale
      from
        pg_catalog.svv_external_columns
      where
        schemaname = 'test_dbt'
        and tablename = 'convert_column_string_to_boolean'

    ),

    unioned as (
      select * from bound_views
      union all
      select * from unbound_views
      union all
      select * from external_views
    )

    select
      column_name,
      data_type,
      character_maximum_length,
      numeric_precision,
      numeric_scale

    from unioned
    
    where table_schema = 'test_dbt'
    
    order by ordinal_position
  
2021-12-02 20:53:05.596336 (Thread-8): SQL status: SELECT in 12.86 seconds
2021-12-02 20:53:05.597182 (Thread-5): SQL status: SELECT in 12.83 seconds
2021-12-02 20:53:05.602049 (Thread-8): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_float_to_string"
2021-12-02 20:53:05.605494 (Thread-5): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_string"
2021-12-02 20:53:05.605949 (Thread-4): SQL status: SELECT in 12.95 seconds
2021-12-02 20:53:05.613474 (Thread-4): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_int"
2021-12-02 20:53:05.613723 (Thread-13): SQL status: SELECT in 12.96 seconds
2021-12-02 20:53:05.618873 (Thread-13): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_string_to_float"
2021-12-02 20:53:05.627477 (Thread-3): SQL status: SELECT in 12.94 seconds
2021-12-02 20:53:05.631054 (Thread-3): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_boolean_to_float"
2021-12-02 20:53:05.631393 (Thread-11): SQL status: SELECT in 12.86 seconds
2021-12-02 20:53:05.636836 (Thread-11): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_string"
2021-12-02 20:53:05.640463 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:05.642332 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_string"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_boolean_to_string" ("column_boolean_to_string", "insert_time")
    (
       select "column_boolean_to_string", "insert_time"
       from "convert_column_boolean_to_string__dbt_tmp205201616622"
    );
  
2021-12-02 20:53:05.644082 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:05.646446 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_float"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_boolean_to_float" ("column_boolean_to_float", "insert_time")
    (
       select "column_boolean_to_float", "insert_time"
       from "convert_column_boolean_to_float__dbt_tmp205201607803"
    );
  
2021-12-02 20:53:05.647135 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:05.649515 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:05.652010 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_boolean_to_int"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_boolean_to_int" ("column_boolean_to_int", "insert_time")
    (
       select "column_boolean_to_int", "insert_time"
       from "convert_column_boolean_to_int__dbt_tmp205201612365"
    );
  
2021-12-02 20:53:05.652428 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:05.657260 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_string"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_float_to_string" ("column_float_to_string", "insert_time")
    (
       select "column_float_to_string", "insert_time"
       from "convert_column_float_to_string__dbt_tmp205201636459"
    );
  
2021-12-02 20:53:05.655550 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:05.653804 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_float"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_string_to_float" ("column_string_to_float", "insert_time")
    (
       select "column_string_to_float", "insert_time"
       from "convert_column_string_to_float__dbt_tmp205201555526"
    );
  
2021-12-02 20:53:05.660556 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_string"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_string" ("column_int_to_string", "insert_time")
    (
       select "column_int_to_string", "insert_time"
       from "convert_column_int_to_string__dbt_tmp205201665695"
    );
  
2021-12-02 20:53:05.665923 (Thread-2): SQL status: SELECT in 12.90 seconds
2021-12-02 20:53:05.668662 (Thread-2): Writing runtime SQL for node "model.incremental_test_schema_change.column_with_quotes"
2021-12-02 20:53:05.672647 (Thread-2): Using redshift connection "model.incremental_test_schema_change.column_with_quotes".
2021-12-02 20:53:05.673035 (Thread-1): SQL status: SELECT in 12.99 seconds
2021-12-02 20:53:05.673825 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.column_with_quotes"} */

      

    insert into "integrationtests"."test_dbt"."column_with_quotes" ("column`_'with"_quotes", "insert_time")
    (
       select "column`_'with"_quotes", "insert_time"
       from "column_with_quotes__dbt_tmp205201621301"
    );
  
2021-12-02 20:53:05.676581 (Thread-1): Writing runtime SQL for node "model.incremental_test_schema_change.change_column_names"
2021-12-02 20:53:05.682132 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:05.683455 (Thread-1): On model.incremental_test_schema_change.change_column_names: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.change_column_names"} */

      

    insert into "integrationtests"."test_dbt"."change_column_names" ("column_name", "column_to_rename", "column_to_delete", "insert_time")
    (
       select "column_name", "column_to_rename", "column_to_delete", "insert_time"
       from "change_column_names__dbt_tmp205201602970"
    );
  
2021-12-02 20:53:05.702979 (Thread-6): SQL status: SELECT in 12.93 seconds
2021-12-02 20:53:05.707235 (Thread-6): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_float_to_boolean"
2021-12-02 20:53:05.711868 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:05.713280 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_boolean"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_float_to_boolean" ("column_float_to_boolean", "insert_time")
    (
       select "column_float_to_boolean", "insert_time"
       from "convert_column_float_to_boolean__dbt_tmp205201630033"
    );
  
2021-12-02 20:53:05.750912 (Thread-14): SQL status: SELECT in 13.03 seconds
2021-12-02 20:53:05.756236 (Thread-14): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_string_to_int"
2021-12-02 20:53:05.761825 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:05.762971 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_int"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_string_to_int" ("column_string_to_int", "insert_time")
    (
       select "column_string_to_int", "insert_time"
       from "convert_column_string_to_int__dbt_tmp205201677841"
    );
  
2021-12-02 20:53:05.777312 (Thread-7): SQL status: SELECT in 13.01 seconds
2021-12-02 20:53:05.781418 (Thread-7): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_float_to_int"
2021-12-02 20:53:05.786869 (Thread-12): SQL status: SELECT in 13.01 seconds
2021-12-02 20:53:05.787943 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:05.790246 (Thread-12): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_string_to_boolean"
2021-12-02 20:53:05.791920 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_float_to_int"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_float_to_int" ("column_float_to_int", "insert_time")
    (
       select "column_float_to_int", "insert_time"
       from "convert_column_float_to_int__dbt_tmp205201625847"
    );
  
2021-12-02 20:53:05.797230 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:05.798548 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_string_to_boolean"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_string_to_boolean" ("column_string_to_boolean", "insert_time")
    (
       select "column_string_to_boolean", "insert_time"
       from "convert_column_string_to_boolean__dbt_tmp205201645719"
    );
  
2021-12-02 20:53:05.800971 (Thread-10): SQL status: SELECT in 13.03 seconds
2021-12-02 20:53:05.803917 (Thread-10): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_float"
2021-12-02 20:53:05.808393 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:05.809555 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_float"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_float" ("column_int_to_float", "insert_time")
    (
       select "column_int_to_float", "insert_time"
       from "convert_column_int_to_float__dbt_tmp205201594424"
    );
  
2021-12-02 20:53:05.817673 (Thread-2): Postgres error: syntax error at or near "_quotes"
LINE 5: ..."."test_dbt"."column_with_quotes" ("column`_'with"_quotes", ...
                                                             ^

2021-12-02 20:53:05.818942 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: ROLLBACK
2021-12-02 20:53:05.823601 (Thread-9): SQL status: SELECT in 13.06 seconds
2021-12-02 20:53:05.826186 (Thread-9): Writing runtime SQL for node "model.incremental_test_schema_change.convert_column_int_to_boolean"
2021-12-02 20:53:05.830138 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:05.831575 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: /* {"app": "dbt", "dbt_version": "0.21.0", "profile_name": "tests", "target_name": "prod", "node_id": "model.incremental_test_schema_change.convert_column_int_to_boolean"} */

      

    insert into "integrationtests"."test_dbt"."convert_column_int_to_boolean" ("column_int_to_boolean", "insert_time")
    (
       select "column_int_to_boolean", "insert_time"
       from "convert_column_int_to_boolean__dbt_tmp205201641100"
    );
  
2021-12-02 20:53:05.922011 (Thread-2): finished collecting timing info
2021-12-02 20:53:05.924880 (Thread-4): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:53:05.925819 (Thread-2): On model.incremental_test_schema_change.column_with_quotes: Close
2021-12-02 20:53:05.943213 (Thread-3): SQL status: INSERT 0 1 in 0.29 seconds
2021-12-02 20:53:05.943982 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: COMMIT
2021-12-02 20:53:05.945981 (Thread-2): Database Error in model column_with_quotes (models/column_with_quotes.sql)
  syntax error at or near "_quotes"
  LINE 5: ..."."test_dbt"."column_with_quotes" ("column`_'with"_quotes", ...
                                                               ^
  compiled SQL at target/run/incremental_test_schema_change/models/column_with_quotes.sql
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 56, in exception_handler
    yield
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 80, in add_query
    cursor.execute(sql, bindings)
psycopg2.errors.SyntaxError: syntax error at or near "_quotes"
LINE 5: ..."."test_dbt"."column_with_quotes" ("column`_'with"_quotes", ...
                                                             ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 348, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 291, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/base.py", line 393, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/site-packages/dbt/task/run.py", line 249, in execute
    result = MacroGenerator(materialization_macro, context)()
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 169, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 333, in __call__
    return self.call_macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/clients/jinja.py", line 260, in call_macro
    return macro(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 675, in __call__
    return self._invoke(arguments, autoescape)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 679, in _invoke
    rv = self._func(*arguments)
  File "<template>", line 41, in macro
  File "/usr/local/lib/python3.8/site-packages/jinja2/sandbox.py", line 462, in call
    return __context.call(__obj, *args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/jinja2/runtime.py", line 290, in call
    return __obj(*args, **kwargs)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/base/impl.py", line 226, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 131, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/sql/connections.py", line 87, in add_query
    return connection, cursor
  File "/usr/local/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/site-packages/dbt/adapters/postgres/connections.py", line 67, in exception_handler
    raise dbt.exceptions.DatabaseException(str(e).strip()) from e
dbt.exceptions.DatabaseException: Database Error in model column_with_quotes (models/column_with_quotes.sql)
  syntax error at or near "_quotes"
  LINE 5: ..."."test_dbt"."column_with_quotes" ("column`_'with"_quotes", ...
                                                               ^
  compiled SQL at target/run/incremental_test_schema_change/models/column_with_quotes.sql
2021-12-02 20:53:05.950368 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: COMMIT
2021-12-02 20:53:05.951618 (Thread-1): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:53:05.953315 (Thread-4): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_int".
2021-12-02 20:53:05.959736 (Thread-2): 20:53:05 | 2 of 14 ERROR creating incremental model test_dbt.column_with_quotes......................................... [ERROR in 64.55s]
2021-12-02 20:53:05.961822 (Thread-3): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_float".
2021-12-02 20:53:05.971297 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: COMMIT
2021-12-02 20:53:05.965500 (Thread-11): SQL status: INSERT 0 1 in 0.30 seconds
2021-12-02 20:53:05.967605 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: COMMIT
2021-12-02 20:53:05.969738 (Thread-2): Finished running node model.incremental_test_schema_change.column_with_quotes
2021-12-02 20:53:05.965200 (Thread-1): On model.incremental_test_schema_change.change_column_names: COMMIT
2021-12-02 20:53:05.973712 (Thread-13): SQL status: INSERT 0 1 in 0.31 seconds
2021-12-02 20:53:05.975724 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: COMMIT
2021-12-02 20:53:05.979503 (Thread-5): SQL status: INSERT 0 1 in 0.33 seconds
2021-12-02 20:53:05.980682 (Thread-1): Using redshift connection "model.incremental_test_schema_change.change_column_names".
2021-12-02 20:53:05.983628 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: COMMIT
2021-12-02 20:53:05.984996 (Thread-11): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_string".
2021-12-02 20:53:05.988283 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: COMMIT
2021-12-02 20:53:05.989827 (Thread-1): On model.incremental_test_schema_change.change_column_names: COMMIT
2021-12-02 20:53:05.991355 (Thread-13): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_float".
2021-12-02 20:53:05.992750 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: COMMIT
2021-12-02 20:53:05.993870 (Thread-6): SQL status: INSERT 0 1 in 0.28 seconds
2021-12-02 20:53:05.994219 (Thread-8): SQL status: INSERT 0 1 in 0.34 seconds
2021-12-02 20:53:05.994514 (Thread-5): Using redshift connection "model.incremental_test_schema_change.convert_column_boolean_to_string".
2021-12-02 20:53:05.997522 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: COMMIT
2021-12-02 20:53:06.001289 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: COMMIT
2021-12-02 20:53:06.003482 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: COMMIT
2021-12-02 20:53:06.004736 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: COMMIT
2021-12-02 20:53:06.007034 (Thread-6): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_boolean".
2021-12-02 20:53:06.008268 (Thread-8): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_string".
2021-12-02 20:53:06.010669 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: COMMIT
2021-12-02 20:53:06.012043 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: COMMIT
2021-12-02 20:53:06.072238 (Thread-12): SQL status: INSERT 0 1 in 0.27 seconds
2021-12-02 20:53:06.077113 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: COMMIT
2021-12-02 20:53:06.079050 (Thread-12): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_boolean".
2021-12-02 20:53:06.080693 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: COMMIT
2021-12-02 20:53:06.092147 (Thread-10): SQL status: INSERT 0 1 in 0.28 seconds
2021-12-02 20:53:06.093798 (Thread-7): SQL status: INSERT 0 1 in 0.30 seconds
2021-12-02 20:53:06.095680 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: COMMIT
2021-12-02 20:53:06.096069 (Thread-14): SQL status: INSERT 0 1 in 0.33 seconds
2021-12-02 20:53:06.098779 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: COMMIT
2021-12-02 20:53:06.100590 (Thread-10): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_float".
2021-12-02 20:53:06.103207 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: COMMIT
2021-12-02 20:53:06.105064 (Thread-7): Using redshift connection "model.incremental_test_schema_change.convert_column_float_to_int".
2021-12-02 20:53:06.106652 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: COMMIT
2021-12-02 20:53:06.108024 (Thread-9): SQL status: INSERT 0 1 in 0.28 seconds
2021-12-02 20:53:06.108287 (Thread-14): Using redshift connection "model.incremental_test_schema_change.convert_column_string_to_int".
2021-12-02 20:53:06.110303 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: COMMIT
2021-12-02 20:53:06.115939 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: COMMIT
2021-12-02 20:53:06.117830 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: COMMIT
2021-12-02 20:53:06.120983 (Thread-9): Using redshift connection "model.incremental_test_schema_change.convert_column_int_to_boolean".
2021-12-02 20:53:06.124489 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: COMMIT
2021-12-02 20:53:06.529768 (Thread-6): SQL status: COMMIT in 0.52 seconds
2021-12-02 20:53:06.532546 (Thread-5): SQL status: COMMIT in 0.52 seconds
2021-12-02 20:53:06.532938 (Thread-11): SQL status: COMMIT in 0.53 seconds
2021-12-02 20:53:06.533180 (Thread-8): SQL status: COMMIT in 0.52 seconds
2021-12-02 20:53:06.534135 (Thread-6): finished collecting timing info
2021-12-02 20:53:06.534625 (Thread-1): SQL status: COMMIT in 0.54 seconds
2021-12-02 20:53:06.534892 (Thread-13): SQL status: COMMIT in 0.53 seconds
2021-12-02 20:53:06.548928 (Thread-13): finished collecting timing info
2021-12-02 20:53:06.550617 (Thread-13): On model.incremental_test_schema_change.convert_column_string_to_float: Close
2021-12-02 20:53:06.539612 (Thread-11): finished collecting timing info
2021-12-02 20:53:06.539866 (Thread-9): SQL status: COMMIT in 0.41 seconds
2021-12-02 20:53:06.540185 (Thread-7): SQL status: COMMIT in 0.42 seconds
2021-12-02 20:53:06.540800 (Thread-3): SQL status: COMMIT in 0.57 seconds
2021-12-02 20:53:06.541055 (Thread-4): SQL status: COMMIT in 0.56 seconds
2021-12-02 20:53:06.542216 (Thread-8): finished collecting timing info
2021-12-02 20:53:06.544144 (Thread-6): On model.incremental_test_schema_change.convert_column_float_to_boolean: Close
2021-12-02 20:53:06.544446 (Thread-12): SQL status: COMMIT in 0.46 seconds
2021-12-02 20:53:06.546600 (Thread-1): finished collecting timing info
2021-12-02 20:53:06.546954 (Thread-14): SQL status: COMMIT in 0.42 seconds
2021-12-02 20:53:06.535083 (Thread-10): SQL status: COMMIT in 0.42 seconds
2021-12-02 20:53:06.574105 (Thread-10): finished collecting timing info
2021-12-02 20:53:06.575834 (Thread-10): On model.incremental_test_schema_change.convert_column_int_to_float: Close
2021-12-02 20:53:06.554175 (Thread-11): On model.incremental_test_schema_change.convert_column_int_to_string: Close
2021-12-02 20:53:06.556251 (Thread-9): finished collecting timing info
2021-12-02 20:53:06.558208 (Thread-7): finished collecting timing info
2021-12-02 20:53:06.560311 (Thread-3): finished collecting timing info
2021-12-02 20:53:06.562750 (Thread-4): finished collecting timing info
2021-12-02 20:53:06.564483 (Thread-8): On model.incremental_test_schema_change.convert_column_float_to_string: Close
2021-12-02 20:53:06.566635 (Thread-6): 20:53:06 | 6 of 14 OK created incremental model test_dbt.convert_column_float_to_boolean................................ [INSERT 0 1 in 65.16s]
2021-12-02 20:53:06.568558 (Thread-12): finished collecting timing info
2021-12-02 20:53:06.570200 (Thread-1): On model.incremental_test_schema_change.change_column_names: Close
2021-12-02 20:53:06.572023 (Thread-14): finished collecting timing info
2021-12-02 20:53:06.537561 (Thread-5): finished collecting timing info
2021-12-02 20:53:06.553127 (Thread-13): 20:53:06 | 13 of 14 OK created incremental model test_dbt.convert_column_string_to_float................................ [INSERT 0 1 in 65.16s]
2021-12-02 20:53:06.596965 (Thread-13): Finished running node model.incremental_test_schema_change.convert_column_string_to_float
2021-12-02 20:53:06.579904 (Thread-11): 20:53:06 | 11 of 14 OK created incremental model test_dbt.convert_column_int_to_string.................................. [INSERT 0 1 in 65.16s]
2021-12-02 20:53:06.581461 (Thread-9): On model.incremental_test_schema_change.convert_column_int_to_boolean: Close
2021-12-02 20:53:06.583018 (Thread-7): On model.incremental_test_schema_change.convert_column_float_to_int: Close
2021-12-02 20:53:06.584807 (Thread-3): On model.incremental_test_schema_change.convert_column_boolean_to_float: Close
2021-12-02 20:53:06.586389 (Thread-4): On model.incremental_test_schema_change.convert_column_boolean_to_int: Close
2021-12-02 20:53:06.588814 (Thread-8): 20:53:06 | 8 of 14 OK created incremental model test_dbt.convert_column_float_to_string................................. [INSERT 0 1 in 65.18s]
2021-12-02 20:53:06.589755 (Thread-6): Finished running node model.incremental_test_schema_change.convert_column_float_to_boolean
2021-12-02 20:53:06.591044 (Thread-12): On model.incremental_test_schema_change.convert_column_string_to_boolean: Close
2021-12-02 20:53:06.593188 (Thread-1): 20:53:06 | 1 of 14 OK created incremental model test_dbt.change_column_names............................................ [INSERT 0 1 in 65.22s]
2021-12-02 20:53:06.593971 (Thread-14): On model.incremental_test_schema_change.convert_column_string_to_int: Close
2021-12-02 20:53:06.595478 (Thread-5): On model.incremental_test_schema_change.convert_column_boolean_to_string: Close
2021-12-02 20:53:06.578074 (Thread-10): 20:53:06 | 10 of 14 OK created incremental model test_dbt.convert_column_int_to_float................................... [INSERT 0 1 in 65.16s]
2021-12-02 20:53:06.600042 (Thread-11): Finished running node model.incremental_test_schema_change.convert_column_int_to_string
2021-12-02 20:53:06.601875 (Thread-9): 20:53:06 | 9 of 14 OK created incremental model test_dbt.convert_column_int_to_boolean.................................. [INSERT 0 1 in 65.19s]
2021-12-02 20:53:06.603150 (Thread-7): 20:53:06 | 7 of 14 OK created incremental model test_dbt.convert_column_float_to_int.................................... [INSERT 0 1 in 65.19s]
2021-12-02 20:53:06.604616 (Thread-3): 20:53:06 | 3 of 14 OK created incremental model test_dbt.convert_column_boolean_to_float................................ [INSERT 0 1 in 65.20s]
2021-12-02 20:53:06.605963 (Thread-4): 20:53:06 | 4 of 14 OK created incremental model test_dbt.convert_column_boolean_to_int.................................. [INSERT 0 1 in 65.20s]
2021-12-02 20:53:06.607645 (Thread-8): Finished running node model.incremental_test_schema_change.convert_column_float_to_string
2021-12-02 20:53:06.610752 (Thread-12): 20:53:06 | 12 of 14 OK created incremental model test_dbt.convert_column_string_to_boolean.............................. [INSERT 0 1 in 65.19s]
2021-12-02 20:53:06.611983 (Thread-1): Finished running node model.incremental_test_schema_change.change_column_names
2021-12-02 20:53:06.613601 (Thread-14): 20:53:06 | 14 of 14 OK created incremental model test_dbt.convert_column_string_to_int.................................. [INSERT 0 1 in 65.17s]
2021-12-02 20:53:06.615068 (Thread-5): 20:53:06 | 5 of 14 OK created incremental model test_dbt.convert_column_boolean_to_string............................... [INSERT 0 1 in 65.21s]
2021-12-02 20:53:06.616116 (Thread-10): Finished running node model.incremental_test_schema_change.convert_column_int_to_float
2021-12-02 20:53:06.618813 (Thread-9): Finished running node model.incremental_test_schema_change.convert_column_int_to_boolean
2021-12-02 20:53:06.620347 (Thread-7): Finished running node model.incremental_test_schema_change.convert_column_float_to_int
2021-12-02 20:53:06.621630 (Thread-3): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_float
2021-12-02 20:53:06.623217 (Thread-4): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_int
2021-12-02 20:53:06.625849 (Thread-12): Finished running node model.incremental_test_schema_change.convert_column_string_to_boolean
2021-12-02 20:53:06.628462 (Thread-14): Finished running node model.incremental_test_schema_change.convert_column_string_to_int
2021-12-02 20:53:06.629918 (Thread-5): Finished running node model.incremental_test_schema_change.convert_column_boolean_to_string
2021-12-02 20:53:06.643564 (MainThread): Acquiring new redshift connection "master".
2021-12-02 20:53:06.644917 (MainThread): Using redshift connection "master".
2021-12-02 20:53:06.646097 (MainThread): On master: BEGIN
2021-12-02 20:53:06.647221 (MainThread): Opening a new connection, currently in state closed
2021-12-02 20:53:06.648490 (MainThread): Connecting to Redshift using 'database' credentials
2021-12-02 20:53:07.718148 (MainThread): SQL status: BEGIN in 1.07 seconds
2021-12-02 20:53:07.723041 (MainThread): On master: COMMIT
2021-12-02 20:53:07.725189 (MainThread): Using redshift connection "master".
2021-12-02 20:53:07.726758 (MainThread): On master: COMMIT
2021-12-02 20:53:07.905474 (MainThread): SQL status: COMMIT in 0.18 seconds
2021-12-02 20:53:07.907888 (MainThread): On master: Close
2021-12-02 20:53:07.910205 (MainThread): 20:53:07 | 
2021-12-02 20:53:07.911870 (MainThread): 20:53:07 | Finished running 14 incremental models in 71.78s.
2021-12-02 20:53:07.914024 (MainThread): Connection 'master' was properly closed.
2021-12-02 20:53:07.915959 (MainThread): Connection 'model.incremental_test_schema_change.change_column_names' was properly closed.
2021-12-02 20:53:07.917429 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_float' was properly closed.
2021-12-02 20:53:07.918608 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_float' was properly closed.
2021-12-02 20:53:07.919961 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_int' was properly closed.
2021-12-02 20:53:07.921211 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_boolean_to_string' was properly closed.
2021-12-02 20:53:07.922645 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_boolean' was properly closed.
2021-12-02 20:53:07.924453 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_int' was properly closed.
2021-12-02 20:53:07.926008 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_float_to_string' was properly closed.
2021-12-02 20:53:07.927409 (MainThread): Connection 'model.incremental_test_schema_change.column_with_quotes' was properly closed.
2021-12-02 20:53:07.928889 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_boolean' was properly closed.
2021-12-02 20:53:07.930556 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_float' was properly closed.
2021-12-02 20:53:07.932076 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_int_to_string' was properly closed.
2021-12-02 20:53:07.933588 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_boolean' was properly closed.
2021-12-02 20:53:07.935111 (MainThread): Connection 'model.incremental_test_schema_change.convert_column_string_to_int' was properly closed.
2021-12-02 20:53:07.951281 (MainThread): 
2021-12-02 20:53:07.952900 (MainThread): Completed with 1 error and 0 warnings:
2021-12-02 20:53:07.954839 (MainThread): 
2021-12-02 20:53:07.956871 (MainThread): Database Error in model column_with_quotes (models/column_with_quotes.sql)
2021-12-02 20:53:07.958898 (MainThread):   syntax error at or near "_quotes"
2021-12-02 20:53:07.961073 (MainThread):   LINE 5: ..."."test_dbt"."column_with_quotes" ("column`_'with"_quotes", ...
2021-12-02 20:53:07.963374 (MainThread):                                                                ^
2021-12-02 20:53:07.965299 (MainThread):   compiled SQL at target/run/incremental_test_schema_change/models/column_with_quotes.sql
2021-12-02 20:53:07.967093 (MainThread): 
Done. PASS=13 WARN=0 ERROR=1 SKIP=0 TOTAL=14
2021-12-02 20:53:07.969057 (MainThread): Flushing usage events
